<?php

/**
 * @file
 * Module file for the entity API.
 */

module_load_include('inc', 'entity', 'modules/callbacks');
module_load_include('inc', 'entity', 'includes/entity.property');


/**
 * Defines status codes used for exportable entities.
 */

/**
 * A bit flag used to let us know if an entity is in the database.
 */


/**
 * A bit flag used to let us know if an entity has been customly defined.
 */
define('ENTITY_CUSTOM', 0x01);

/**
 * Deprecated, but still here for backward compatibility.
 */
define('ENTITY_IN_DB', 0x01);

/**
 * A bit flag used to let us know if an entity is a 'default' in code.
 */
define('ENTITY_IN_CODE', 0x02);

/**
 * A bit flag used to mark entities as overridden, e.g. they were originally
 * definded in code and are saved now in the database. Same as
 * (ENTITY_CUSTOM | ENTITY_IN_CODE).
 */
define('ENTITY_OVERRIDDEN', 0x03);

/**
 * A bit flag used to mark entities as fixed, thus not changeable for any
 * user.
 */
define('ENTITY_FIXED', 0x04 | 0x02);



/**
 * Determines whether for the given entity type a given operation is available.
 *
 * @param $entity_type
 *   The type of the entity.
 * @param $op
 *   One of 'create', 'view', 'save', 'delete' or 'access.
 */
function entity_type_supports($entity_type, $op) {
  $info = entity_get_info($entity_type);
  $keys = array(
    'view' => 'view callback',
    'create' => 'creation callback',
    'delete' => 'deletion callback',
    'save' => 'save callback',
    'access' => 'access callback',
  );
  if (isset($info[$keys[$op]]) || ($op != 'access' && in_array('EntityAPIControllerInterface', class_implements($info['controller class'])))) {
    return TRUE;
  }
}

/**
 * Menu loader function: load an entity from its path.
 *
 * This can be used to load entities of all types in menu paths:
 *
 * @code
 * $items['myentity/%entity_object'] = array(
 *   'load arguments' => array('myentity'),
 *   'title' => ...,
 *   'page callback' => ...,
 *   'page arguments' => array(...),
 *   'access arguments' => array(...),
 * );
 * @endcode
 *
 * @param $entity_id
 *   The ID of the entity to load, passed by the menu URL.
 * @param $entity_type
 *   The type of the entity to load.
 * @return
 *   A fully loaded entity object, or FALSE in case of error.
 */
function entity_object_load($entity_id, $entity_type) {
  $entities = entity_load($entity_type, array($entity_id));
  return reset($entities);
}

/**
 * A wrapper around entity_load() to load a single entity by name or numeric id.
 *
 * @todo: Re-name entity_load() to entity_load_multiple() in d8 core and this
 * to entity_load().
 *
 * @param $entity_type
 *   The entity type to load, e.g. node or user.
 * @param $id
 *   The entity id, either the numeric id or the entity name. In case the entity
 *   type has specified a name key, both the numeric id and the name may be
 *   passed.
 *
 * @return
 *   The entity object, or FALSE.
 *
 * @see entity_load()
 */
function entity_load_single($entity_type, $id) {
  $entities = entity_load($entity_type, array($id));
  return reset($entities);
}

/**
 * A wrapper around entity_load() to return entities keyed by name key if existing.
 *
 * @param $entity_type
 *   The entity type to load, e.g. node or user.
 * @param $names
 *   An array of entity names or ids, or FALSE to load all entities.
 * @param $conditions
 *   (deprecated) An associative array of conditions on the base table, where
 *   the keys are the database fields and the values are the values those
 *   fields must have. Instead, it is preferable to use EntityFieldQuery to
 *   retrieve a list of entity IDs loadable by this function.
 *
 * @return
 *   An array of entity objects indexed by their names (or ids if the entity
 *   type has no name key).
 *
 * @see entity_load()
 */
function entity_load_multiple_by_name($entity_type, $names = FALSE, $conditions = array()) {
  $entities = entity_load($entity_type, $names, $conditions);
  $info = entity_get_info($entity_type);
  if (!isset($info['entity keys']['name'])) {
    return $entities;
  }
  return entity_key_array_by_property($entities, $info['entity keys']['name']);
}

/**
 * Permanently save an entity.
 *
 * In case of failures, an exception is thrown.
 *
 * @param $entity_type
 *   The type of the entity.
 * @param $entity
 *   The entity to save.
 *
 * @return
 *   For entity types provided by the CRUD API, SAVED_NEW or SAVED_UPDATED is
 *   returned depending on the operation performed. If there is no information
 *   how to save the entity, FALSE is returned.
 *
 * @see entity_type_supports()
 */
function entity_save($entity_type, $entity) {
  $info = entity_get_info($entity_type);
  if (method_exists($entity, 'save')) {
    return $entity->save();
  }
  elseif (isset($info['save callback'])) {
    $info['save callback']($entity);
  }
  elseif (in_array('EntityAPIControllerInterface', class_implements($info['controller class']))) {
    return entity_get_controller($entity_type)->save($entity);
  }
  else {
    return FALSE;
  }
}

/**
 * Permanently delete the given entity.
 *
 * In case of failures, an exception is thrown.
 *
 * @param $entity_type
 *   The type of the entity.
 * @param $id
 *   The uniform identifier of the entity to delete.
 *
 * @return
 *   FALSE, if there were no information how to delete the entity.
 *
 * @see entity_type_supports()
 */
function entity_delete($entity_type, $id) {
  return entity_delete_multiple($entity_type, array($id));
}

/**
 * Permanently delete multiple entities.
 *
 * @param $entity_type
 *   The type of the entity.
 * @param $ids
 *   An array of entity ids of the entities to delete. In case the entity makes
 *   use of a name key, both the names or numeric ids may be passed.
 * @return
 *   FALSE if the given entity type isn't compatible to the CRUD API.
 */
function entity_delete_multiple($entity_type, $ids) {
  $info = entity_get_info($entity_type);
  if (isset($info['deletion callback'])) {
    foreach ($ids as $id) {
      $info['deletion callback']($id);
    }
  }
  elseif (in_array('EntityAPIControllerInterface', class_implements($info['controller class']))) {
    entity_get_controller($entity_type)->delete($ids);
  }
  else {
    return FALSE;
  }
}

/**
 * Create a new entity object.
 *
 * @param $entity_type
 *   The type of the entity.
 * @param $values
 *   An array of values to set, keyed by property name. If the entity type has
 *   bundles the bundle key has to be specified.
 * @return
 *   A new instance of the entity type or FALSE if there is no information for
 *   the given entity type.
 *
 * @see entity_type_supports()
 */
function entity_create($entity_type, array $values) {
  $info = entity_get_info($entity_type);
  if (isset($info['creation callback'])) {
    return $info['creation callback']($values, $entity_type);
  }
  elseif (in_array('EntityAPIControllerInterface', class_implements($info['controller class']))) {
    return entity_get_controller($entity_type)->create($values);
  }
  return FALSE;
}

/**
 * Exports an entity.
 *
 * Note: Currently, this only works for entity types provided with the entity
 * CRUD API.
 *
 * @param $entity_type
 *   The type of the entity.
 * @param $entity
 *   The entity to export.
 * @param $prefix
 *   An optional prefix for each line.
 * @return
 *   The exported entity as serialized string. The format is determined by the
 *   respective entity controller, e.g. it is JSON for the EntityAPIController.
 *   The output is suitable for entity_import().
 */
function entity_export($entity_type, $entity, $prefix = '') {
  if (method_exists($entity, 'export')) {
    return $entity->export($prefix);
  }
  $info = entity_get_info($entity_type);
  if (in_array('EntityAPIControllerInterface', class_implements($info['controller class']))) {
    return entity_get_controller($entity_type)->export($entity, $prefix);
  }
}

/**
 * Imports an entity.
 *
 * Note: Currently, this only works for entity types provided with the entity
 * CRUD API.
 *
 * @param $entity_type
 *   The type of the entity.
 * @param string $export
 *   The string containing the serialized entity as produced by
 *   entity_export().
 * @return
 *   The imported entity object not yet saved.
 */
function entity_import($entity_type, $export) {
  $info = entity_get_info($entity_type);
  if (in_array('EntityAPIControllerInterface', class_implements($info['controller class']))) {
    return entity_get_controller($entity_type)->import($export);
  }
}

/**
 * Builds a structured array representing the entity's content.
 *
 * The content built for the entity will vary depending on the $view_mode
 * parameter.
 *
 * Note: Currently, this only works for entity types provided with the entity
 * CRUD API.
 *
 * @param $entity_type
 *   The type of the entity.
 * @param $entity
 *   An entity object.
 * @param $view_mode
 *   A view mode as used by this entity type, e.g. 'full', 'teaser'...
 * @param $langcode
 *   (optional) A language code to use for rendering. Defaults to the global
 *   content language of the current request.
 * @return
 *   The renderable array.
 */
function entity_build_content($entity_type, $entity, $view_mode = 'full', $langcode = NULL) {
  $info = entity_get_info($entity_type);
  if (method_exists($entity, 'buildContent')) {
    return $entity->buildContent($view_mode, $langcode);
  }
  elseif (in_array('EntityAPIControllerInterface', class_implements($info['controller class']))) {
    return entity_get_controller($entity_type)->buildContent($entity, $view_mode, $langcode);
  }
}

/**
 * Returns the entity identifier, i.e. the entities name or numeric id.
 *
 * Unlike entity_extract_ids() this function returns the name of the entity
 * instead of the numeric id, in case the entity type has specified a name key.
 *
 * @param $entity_type
 *   The type of the entity.
 * @param $entity
 *   An entity object.
 *
 * @see entity_extract_ids()
 */
function entity_id($entity_type, $entity) {
  if (method_exists($entity, 'identifier')) {
    return $entity->identifier();
  }
  $info = entity_get_info($entity_type);
  $key = isset($info['entity keys']['name']) ? $info['entity keys']['name'] : $info['entity keys']['id'];
  return isset($entity->$key) ? $entity->$key : NULL;
}

/**
 * Generate an array for rendering the given entities.
 *
 * Entities being viewed, are generally expected to be fully-loaded entity
 * objects, thus have their name or id key set. However, it is possible to
 * view a single entity without any id, e.g. for generating a preview during
 * creation.
 *
 * @param $entity_type
 *   The type of the entity.
 * @param $entities
 *   An array of entities to render.
 * @param $view_mode
 *   A view mode as used by this entity type, e.g. 'full', 'teaser'...
 * @param $langcode
 *   (optional) A language code to use for rendering. Defaults to the global
 *   content language of the current request.
 * @param $page
 *   (optional) If set will control if the entity is rendered: if TRUE
 *   the entity will be rendered without its title, so that it can be embeded
 *   in another context. If FALSE the entity will be displayed with its title
 *   in a mode suitable for lists.
 *   If unset, the page mode will be enabled if the current path is the URI
 *   of the entity, as returned by entity_uri().
 *   This parameter is only supported for entities which controller is a
 *   EntityAPIControllerInterface.
 * @return
 *   The renderable array, keyed by name key if existing or by numeric id else.
 *   If there is no information on how to view an entity, FALSE is returned.
 */
function entity_view($entity_type, $entities, $view_mode = 'full', $langcode = NULL, $page = NULL) {
  $info = entity_get_info($entity_type);
  if (isset($info['view callback'])) {
    return $info['view callback']($entities, $view_mode, $langcode, $entity_type);
  }
  elseif (in_array('EntityAPIControllerInterface', class_implements($info['controller class']))) {
    return entity_get_controller($entity_type)->view($entities, $view_mode, $langcode, $page);
  }
  return FALSE;
}

/**
 * Determines whether the given user has access to an entity.
 *
 * @param $op
 *   The operation being performed. One of 'view', 'update', 'create' or
 *   'delete'.
 * @param $entity_type
 *   The entity type of the entity to check for.
 * @param $entity
 *   Optionally an entity to check access for. If no entity is given, it will be
 *   determined whether access is allowed for all entities of the given type.
 * @param $account
 *   The user to check for. Leave it to NULL to check for the global user.
 *
 * @return boolean
 *   Whether access is allowed or not. If the entity type does not specify any
 *   access information, NULL is returned.
 *
 * @see entity_type_supports()
 */
function entity_access($op, $entity_type, $entity = NULL, $account = NULL) {
  if (($info = entity_get_info()) && isset($info[$entity_type]['access callback'])) {
    return $info[$entity_type]['access callback']($op, $entity, $account, $entity_type);
  }
}

/**
 * Converts an array of entities to be keyed by the values of a given property.
 *
 * @param array $entities
 *   The array of entities to convert.
 * @param $property
 *   The name of entity property, by which the array should be keyed. To get
 *   reasonable results, the property has to have unique values.
 *
 * @return array
 *   The same entities in the same order, but keyed by their $property values.
 */
function entity_key_array_by_property(array $entities, $property) {
  $ret = array();
  foreach ($entities as $entity) {
    $key = isset($entity->$property) ? $entity->$property : NULL;
    $ret[$key] = $entity;
  }
  return $ret;
}

/**
 * Returns an array of entity info for the entity types provided via the entity CRUD API.
 */
function entity_crud_get_info() {
  $types = array();
  foreach (entity_get_info() as $type => $info) {
    if (isset($info['controller class']) && in_array('EntityAPIControllerInterface', class_implements($info['controller class']))) {
      $types[$type] = $info;
    }
  }
  return $types;
}

/**
 * Checks if a given entity has a certain exportable status.
 *
 * @param $entity_type
 *   The type of the entity.
 * @param $entity
 *   The entity to check the status on.
 * @param $status
 *   The constant status like ENTITY_CUSTOM, ENTITY_IN_CODE, ENTITY_OVERRIDDEN
 *   or ENTITY_FIXED.
 *
 * @return
 *   TRUE if the entity has the status, FALSE otherwise.
 */
function entity_has_status($entity_type, $entity, $status) {
  $info = entity_get_info($entity_type);
  $status_key = empty($info['entity keys']['status']) ? 'status' : $info['entity keys']['status'];
  return isset($entity->{$status_key}) && ($entity->{$status_key} & $status) == $status;
}

/**
 * Export a variable. Copied from ctools.
 *
 * This is a replacement for var_export(), allowing us to more nicely
 * format exports. It will recurse down into arrays and will try to
 * properly export bools when it can.
 */
function entity_var_export($var, $prefix = '') {
  if (is_array($var)) {
    if (empty($var)) {
      $output = 'array()';
    }
    else {
      $output = "array(\n";
      foreach ($var as $key => $value) {
        $output .= "  '$key' => " . entity_var_export($value, '  ') . ",\n";
      }
      $output .= ')';
    }
  }
  else if (is_bool($var)) {
    $output = $var ? 'TRUE' : 'FALSE';
  }
  else {
    $output = var_export($var, TRUE);
  }

  if ($prefix) {
    $output = str_replace("\n", "\n$prefix", $output);
  }
  return $output;
}

/**
 * Export a variable in pretty formatted JSON.
 */
function entity_var_json_export($var, $prefix = '') {
  if (is_array($var) && $var) {
    // Defines whether we use a JSON array or object.
    $use_array = ($var == array_values($var));
    $output = $use_array ? "[" : "{";

    foreach ($var as $key => $value) {
      if ($use_array) {
        $values[] = entity_var_json_export($value, '  ');
      }
      else {
        $values[] = entity_var_json_export((string) $key, '  ') . ' : ' . entity_var_json_export($value, '  ');
      }
    }
    // Use several lines for long content. However for objects with a single
    // entry keep the key in the first line.
    if (strlen($content = implode(", ", $values)) > 70 && ($use_array || count($values) > 1)) {
      $output .= "\n  " .  implode(",\n  ", $values) . "\n";
    }
    elseif (strpos($content, "\n") !== FALSE) {
      $output .= " " .  $content . "\n";
    }
    else {
      $output .= " " .  $content . " ";
    }
    $output .= $use_array ? "]" : "}";
  }
  else {
    $output = drupal_json_encode($var);
  }

  if ($prefix) {
    $output = str_replace("\n", "\n$prefix", $output);
  }
  return $output;
}

/**
 * Rebuild the default entities provided in code.
 *
 * Exportable entities provided in code get saved to the database once a module
 * providing defaults in code is activated. This allows module and entity_load()
 * to easily deal with exportable entities just by relying on the database.
 *
 * The defaults get rebuilt if the cache is cleared or new modules providing
 * defaults are enabled, such that the defaults in the database are up to date.
 * A default entity gets updated with the latest defaults in code during rebuild
 * as long as the default has not been overridden. Once a module providing
 * defaults is disabled, its default entities get removed from the database
 * unless they have been overridden. In that case the overridden entity is left
 * in the database, but its status gets updated to 'custom'.
 *
 * @param $entity_types
 *   (optional) If specified, only the defaults of the given entity types are
 *   rebuilt.
 */
function entity_defaults_rebuild($entity_types = NULL) {
  if (isset($entity_types)) {
    $rebuild = variable_get('entity_defaults_built', array());
    variable_set('entity_defaults_built', array_diff_key($rebuild, array_flip($entity_types)));
  }
  else {
    variable_set('entity_defaults_built', array());
  }
}

/**
 * Actually rebuild the defaults, triggered by entity_load().
 */
function _entity_defaults_rebuild($entity_type) {
  if (lock_acquire('entity_rebuild_' . $entity_type)) {
    $built = variable_get('entity_defaults_built', array());
    $built[$entity_type] = TRUE;
    variable_set('entity_defaults_built', $built);

    $info = entity_get_info($entity_type);
    $hook = isset($info['export']['default hook']) ? $info['export']['default hook'] : 'default_' . $entity_type;
    $keys = $info['entity keys'] + array('module' => 'module', 'status' => 'status', 'name' => $info['entity keys']['id']);

    // Check for the existence of the module and status columns.
    if (!in_array($keys['status'], $info['schema_fields_sql']['base table']) || !in_array($keys['module'], $info['schema_fields_sql']['base table'])) {
      trigger_error("Missing database columns for the exportable entity $entity_type as defined by entity_exportable_schema_fields(). Update the according module and run update.php!", E_USER_WARNING);
      return;
    }

    // Invoke the hook and collect default entities.
    $entities = array();
    foreach (module_implements($hook) as $module) {
      foreach ((array) module_invoke($module, $hook) as $name => $entity) {
        $entity->{$keys['name']} = $name;
        $entity->{$keys['module']} = $module;
        $entities[$name] = $entity;
      }
    }
    drupal_alter($hook, $entities);

    // Remove defaults which are already overridden.
    $overridden_entities = entity_load_multiple_by_name($entity_type, array_keys($entities), array($keys['status'] => ENTITY_OVERRIDDEN));
    $entities = array_diff_key($entities, $overridden_entities);

    // Determine already existing, custom entities and mark them as overridden.
    $existing_entities = entity_load_multiple_by_name($entity_type, array_keys($entities), array($keys['status'] => ENTITY_CUSTOM));
    foreach ($existing_entities as $name => $entity) {
      $entity->{$keys['status']} |= ENTITY_OVERRIDDEN;
      $entity->{$keys['module']} = $entities[$name]->{$keys['module']};
      entity_save($entity_type, $entity);
    }

    // Save the defaults being not overridden to the db, possible over-writing
    // previous defaults already saved in the db.
    foreach (array_diff_key($entities, $existing_entities) as $name => $entity) {
      $entity->{$keys['status']} |= ENTITY_IN_CODE;
      // For updating the numeric db identifier has to be set.
      if ($entity->original = entity_load_unchanged($entity_type, $name)) {
        $entity->{$keys['id']} = $entity->original->{$keys['id']};
        unset($entity->is_new);
      }
      $entity->is_rebuild = TRUE;
      entity_save($entity_type, $entity);
    }

    lock_release('entity_rebuild_' . $entity_type);
  }
}

/**
 * Implements hook_modules_enabled().
 */
function entity_modules_enabled($modules) {
  $built_types = variable_get('entity_defaults_built', array());
  if ($entity_types = _entity_modules_get_default_types($modules)) {
    // Determining the entity types might have triggered rebuilding already, in
    // which case we do not need to rebuild again. So we make sure to only
    // add entity-types for rebuilding that were not marked for rebuilding
    // *before our check* anyway.
    foreach ($entity_types as $key => $type) {
      if (!isset($built_types[$type])) {
        unset($entity_types[$key]);
      }
    }
    if ($entity_types) {
      entity_defaults_rebuild($entity_types);
    }
  }
}

/**
 * Implements hook_modules_disabled().
 */
function entity_modules_disabled($modules) {
  foreach (_entity_modules_get_default_types($modules) as $entity_type) {
    $info = entity_get_info($entity_type);

    // Do nothing if the module providing the entity type has been disabled too.
    if (isset($info['module']) && in_array($info['module'], $modules)) {
      return;
    }

    $keys = $info['entity keys'] + array('module' => 'module', 'status' => 'status', 'name' => $info['entity keys']['id']);
    // Remove entities provided in code.
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', $entity_type, '=')
          ->propertyCondition($keys['module'], $modules, 'IN')
          ->propertyCondition($keys['status'], array(ENTITY_IN_CODE, ENTITY_FIXED), 'IN');
    $result = $query->execute();
    if (isset($result[$entity_type])) {
      $entities = entity_load($entity_type, array_keys($result[$entity_type]));
      entity_delete_multiple($entity_type, array_keys($entities));
    }

    // Update overridden entities to be now custom.
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', $entity_type, '=')
          ->propertyCondition($keys['module'], $modules, 'IN')
          ->propertyCondition($keys['status'], ENTITY_OVERRIDDEN, '=');
    $result = $query->execute();
    if (isset($result[$entity_type])) {
      foreach (entity_load($entity_type, array_keys($result[$entity_type])) as $name => $entity) {
        $entity->{$keys['status']} = ENTITY_CUSTOM;
        $entity->{$keys['module']} = NULL;
        entity_save($entity_type, $entity);
      }
    }
  }

}

/**
 * Gets all entity types for which defaults are provided by the $modules.
 */
function _entity_modules_get_default_types($modules) {
  $types = array();
  foreach (entity_crud_get_info() as $entity_type => $info) {
    if (!empty($info['exportable'])) {
      $hook = isset($info['export']['default hook']) ? $info['export']['default hook'] : 'default_' . $entity_type;
      foreach ($modules as $module) {
        if (module_hook($module, $hook) || module_hook($module, $hook . '_alter')) {
          $types[] = $entity_type;
        }
      }
    }
  }
  return $types;
}

/**
 * Defines schema fields required for exportable entities.
 *
 * Warning: Do not call this function in your module's hook_schema()
 * implementation or update functions. It is not safe to call functions of
 * dependencies at this point. Instead of calling the function, just copy over
 * the content.
 * For more details see the issue http://drupal.org/node/1122812.
 */
function entity_exportable_schema_fields($module_col = 'module', $status_col = 'status') {
  return array(
    $status_col => array(
      'type' => 'int',
      'not null' => TRUE,
      // Set the default to ENTITY_CUSTOM without using the constant as it is
      // not safe to use it at this point.
      'default' => 0x01,
      'size' => 'tiny',
      'description' => 'The exportable status of the entity.',
    ),
    $module_col => array(
      'description' => 'The name of the providing module if the entity has been defined in code.',
      'type' => 'varchar',
      'length' => 255,
      'not null' => FALSE,
    ),
  );
}

/**
 * Implements hook_flush_caches().
 */
function entity_flush_caches() {
  entity_property_info_cache_clear();
  entity_defaults_rebuild();
}

/**
 * Implements hook_theme().
 */
function entity_theme() {
  return array(
    'entity_status' => array(
      'variables' => array('status' => NULL, 'html' => TRUE),
    ),
    'entity' => array(
      'render element' => 'elements',
      'template' => 'entity',
    ),
    'entity_ui_overview_item' => array(
      'variables' => array('label' => NULL, 'entity_type' => NULL, 'url' => FALSE, 'name' => FALSE),
      'file' => 'includes/entity.ui.inc'
    ),
  );
}

/**
 * Themes the exportable status of an entity.
 */
function theme_entity_status($variables) {
  $status = $variables['status'];
  $html = $variables['html'];
  if (($status & ENTITY_FIXED) == ENTITY_FIXED) {
    $label = t('Fixed');
    $help = t('The configuration is fixed and cannot be changed.');
    return $html ? "<span class='entity-status-fixed' title='$help'>" . $label . "</span>" : $label;
  }
  elseif (($status & ENTITY_OVERRIDDEN) == ENTITY_OVERRIDDEN) {
    $label = t('Overridden');
    $help = t('This configuration is provided by a module, but has been changed.');
    return $html ? "<span class='entity-status-overridden' title='$help'>" . $label . "</span>" : $label;
  }
  elseif ($status & ENTITY_IN_CODE) {
    $label = t('Default');
    $help = t('A module provides this configuration.');
    return $html ? "<span class='entity-status-default' title='$help'>" . $label . "</span>" : $label;
  }
  elseif ($status & ENTITY_CUSTOM) {
    $label = t('Custom');
    $help = t('A custom configuration by a user.');
    return $html ? "<span class='entity-status-custom' title='$help'>" . $label . "</span>" : $label;
  }
}

/**
 * Process variables for entity.tpl.php.
 */
function template_preprocess_entity(&$variables) {
  $variables['view_mode'] = $variables['elements']['#view_mode'];
  $entity_type = $variables['elements']['#entity_type'];
  $variables['entity_type'] = $entity_type;
  $entity = $variables['elements']['#entity'];
  $variables[$variables['elements']['#entity_type']] = $entity;
  $info = entity_get_info($entity_type);

  $variables['title'] = check_plain(entity_label($entity_type, $entity));
  if (isset($variables['elements']['#page'])) {
    // If set by the caller, respect the page property.
    $variables['page'] = $variables['elements']['#page'];
  }
  else {
    // Else, try to automatically detect it.
    $uri = entity_uri($entity_type, $entity);
    $variables['url'] = $uri ? url($uri['path'], $uri['options']) : FALSE;
    $variables['page'] = $uri && $uri['path'] == $_GET['q'];
  }

  // Helpful $content variable for templates.
  $variables['content'] = array();
  foreach (element_children($variables['elements']) as $key) {
    $variables['content'][$key] = $variables['elements'][$key];
  }

  if (!empty($info['fieldable'])) {
    // Make the field variables available with the appropriate language.
    field_attach_preprocess($entity_type, $entity, $variables['content'], $variables);
  }
  list(, , $bundle) = entity_extract_ids($entity_type, $entity);

  // Gather css classes.
  $variables['classes_array'][] = drupal_html_class('entity-' . $entity_type);
  $variables['classes_array'][] = drupal_html_class($entity_type . '-' . $bundle);

  // Add RDF type and about URI.
  if (module_exists('rdf')) {
    $variables['attributes_array']['about'] = empty($uri['path']) ? NULL: url($uri['path']);
    $variables['attributes_array']['typeof'] = empty($entity->rdf_mapping['rdftype']) ? NULL : $entity->rdf_mapping['rdftype'];
  }

  // Add suggestions.
  $variables['theme_hook_suggestions'][] = $entity_type;
  $variables['theme_hook_suggestions'][] = $entity_type . '__' . $bundle;
  $variables['theme_hook_suggestions'][] = $entity_type . '__' . $bundle . '__' . $variables['view_mode'];
  if ($id = entity_id($entity_type, $entity)) {
    $variables['theme_hook_suggestions'][] = $entity_type . '__' . $id;
  }
}

/**
 * Label callback that refers to the entity classes label method.
 */
function entity_class_label($entity) {
  return $entity->label();
}

/**
 * URI callback that refers to the entity classes uri method.
 */
function entity_class_uri($entity) {
  return $entity->uri();
}

/**
 * Implements hook_file_download_access() for entity types provided by the CRUD API.
 */
function entity_file_download_access($field, $entity_type, $entity) {
  $info = entity_get_info($entity_type);
  if (in_array('EntityAPIControllerInterface', class_implements($info['controller class']))) {
    return entity_access('view', $entity_type, $entity);
  }
}

/**
 * Determines the UI controller class for a given entity type.
 *
 * @return EntityDefaultUIController
 *   If a type is given, the controller for the given entity type. Else an array
 *   of all enabled UI controllers keyed by entity type is returned.
 */
function entity_ui_controller($type = NULL) {
  $static = &drupal_static(__FUNCTION__);
  $all = &drupal_static(__FUNCTION__);

  if (isset($type) && !isset($static[$type])) {
    $info = entity_get_info($type);
    $class = isset($info['admin ui']['controller class']) ? $info['admin ui']['controller class'] : 'EntityDefaultUIController';
    $static[$type] = (isset($info['admin ui']['path']) && $class) ? new $class($type, $info) : FALSE;
  }
  if (!isset($type) && !isset($all)) {
    // Invoke the function for each type to ensure we have fully populated the
    // static variable $static.
    foreach (entity_get_info() as $entity_type => $info) {
      $all[$entity_type] = entity_ui_controller($entity_type);
    }
  }
  if ($type) {
    return isset($static[$type]) ? $static[$type] : FALSE;
  }
  return array_filter($static);
}

/**
 * Implements hook_menu().
 *
 * @see EntityDefaultUIController::hook_menu()
 */
function entity_menu() {
  $items = array();
  foreach (entity_ui_controller() as $controller) {
    $items += $controller->hook_menu();
  }
  return $items;
}

/**
 * Implements hook_forms().
 *
 * @see EntityDefaultUIController::hook_forms()
 * @see entity_ui_get_form()
 */
function entity_forms($form_id, $args) {
  // For efficiency only invoke an entity types controller, if a form of it is
  // requested. Thus if the first (overview and operation form) or the third
  // argument (edit form) is an entity type name, add in the types forms.
  if (isset($args[0]) && is_string($args[0]) && entity_get_info($args[0])) {
    $type = $args[0];
  }
  elseif (isset($args[2]) && is_string($args[2]) && entity_get_info($args[2])) {
    $type = $args[2];
  }
  if (isset($type) && $controller = entity_ui_controller($type)) {
    return $controller->hook_forms();
  }
}

/**
 * Gets an entity form.
 *
 * This function may be used by entities to build their entity form. It has to
 * be used instead of calling drupal_get_form().
 * Entity forms built with this helper receive useful defaults suiting for
 * editing a single entity, whereas the special cases of adding and cloning
 * of entities are supported too.
 *
 * While this function is intended to be used to get entity forms for entities
 * using the entity ui controller, it may be used for entity types not using
 * the ui controller too.
 *
 * @param $entity_type
 *   The entity type for which to get the form.
 * @param $entity
 *   The entity for which to return the form.
 *   If $op is 'add' the entity has to be either initialized before calling this
 *   function, or NULL may be passed. If NULL is passed, an entity will be
 *   initialized with empty values using entity_create(). Thus entities, for
 *   which this is problematic have to care to pass in an initialized entity.
 * @param $op
 *   One of 'edit', 'add' or 'clone'. Defaults to edit.
 *
 * @return
 *   The fully built and processed form, ready to be rendered.
 *
 * @see EntityDefaultUIController::hook_forms()
 * @see entity_ui_form_submit_build_entity()
 */
function entity_ui_get_form($entity_type, $entity, $op = 'edit') {
  if (isset($entity)) {
    list(, , $bundle) = entity_extract_ids($entity_type, $entity);
  }
  $form_id = (!isset($bundle) || $bundle == $entity_type) ? $entity_type . '_form' : $entity_type . '_edit_' . $bundle . '_form';

  if (!isset($entity) && $op == 'add') {
    $entity = entity_create($entity_type, array());
  }

  // Do not use drupal_get_form(), but invoke drupal_build_form() ourself so
  // we can prepulate the form state.
  $form_state['wrapper_callback'] = 'entity_ui_main_form_defaults';
  $form_state['entity_type'] = $entity_type;
  // We don't pass the entity type as first parameter, as the implementing
  // module knows the type anyway. However, in order to allow for efficient
  // hook_forms() implementiations we append the entity type as last argument,
  // which the module implementing the form constructor may safely ignore.
  // @see entity_forms()
  $form_state['build_info']['args'] = array($entity, $op, $entity_type);
  module_load_include('inc', 'entity', 'includes/entity.ui');
  return drupal_build_form($form_id, $form_state);
}

/**
 * Implements hook_views_api().
 */
function entity_views_api() {
  return array(
    'api' => '3.0-alpha1',
    'path' => drupal_get_path('module', 'entity') . '/views',
  );
}

/**
 * Returns a property wrapper for the given data.
 *
 * If an entity is wrapped, the wrapper can be used to retrieve further wrappers
 * for the entitity properties. For that the wrapper support chaining, e.g. you
 * can use a node wrapper to get the node authors mail address:
 *
 * @code
 *   echo $wrappedNode->author->mail->value();
 * @endcode
 *
 * @param $type
 *   The type of the passed data.
 * @param $data
 *   The data to wrap. It may be set to NULL, so the wrapper can be used
 *   without any data for getting information about properties.
 * @param $info
 *   (optional) Specify additional information for the passed data:
 *    - langcode: (optional) If the data is language specific, its langauge
 *      code. Defaults to NULL, what means language neutral.
 *    - bundle: (optional) If an entity is wrapped but not passed, use this key
 *      to specify the bundle to return a wrapper for.
 *    - property info: (optional) May be used to use a wrapper with an arbitrary
 *      data structure (type 'struct'). Use this key for specifying info about
 *      properties in the same structure as used by hook_entity_property_info().
 *    - property info alter: (optional) A callback for altering the property
 *      info before it is utilized by the wrapper.
 *    - property defaults: (optional) An array of defaults for the info of
 *      each property of the wrapped data item.
 * @return EntityMetadataWrapper
 *   Dependend on the passed data the right wrapper is returned.
 */
function entity_metadata_wrapper($type, $data = NULL, array $info = array()) {
  if ($type == 'entity' || (($entity_info = entity_get_info()) && isset($entity_info[$type]))) {
    return new EntityDrupalWrapper($type, $data, $info);
  }
  elseif ($type == 'list' || entity_property_list_extract_type($type)) {
    return new EntityListWrapper($type, $data, $info);
  }
  elseif (isset($info['property info'])) {
    return new EntityStructureWrapper($type, $data, $info);
  }
  else {
    return new EntityValueWrapper($type, $data, $info);
  }
}

/**
 * Returns a metadata wrapper for accessing site-wide properties.
 *
 * Although there is no 'site' entity or such, modules may provide info about
 * site-wide properties using hook_entity_property_info(). This function returns
 * a wrapper for making use of this properties.
 *
 * @return EntityMetadataWrapper
 *   A wrapper for accessing site-wide properties.
 *
 * @see entity_metadata_system_entity_property_info()
 */
function entity_metadata_site_wrapper() {
  $site_info = entity_get_property_info('site');
  $info['property info'] = $site_info['properties'];
  return entity_metadata_wrapper('site', FALSE, $info);
}

/**
 * Implements hook_module_implements_alter().
 *
 * Moves the hook_entity_info_alter() implementation to the bottom so it is
 * invoked after all modules relying on the entity API.
 * That way we ensure to run last and clear the field-info cache after the
 * others added in their bundle information.
 *
 * @see entity_entity_info_alter()
 */
function entity_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'entity_info_alter') {
    // Move our hook implementation to the bottom.
    $group = $implementations['entity'];
    unset($implementations['entity']);
    $implementations['entity'] = $group;
  }
}

/**
 * Implements hook_entity_info_alter().
 *
 * @see entity_module_implements_alter()
 */
function entity_entity_info_alter(&$entity_info) {
  _entity_info_add_metadata_callbacks($entity_info);

  // Modules are using entity_load() in hook_entity_info_alter() to add
  // their bundle-info. This might trigger the field API cache to be built,
  // which makes use of the bundle-info. In that case the field-info cache would
  // have been built with in-complete bundle-info, thus we clear it so it is
  // rebuilt with complete bundle-info the next time field-info is requested.
  _field_info_collate_fields(TRUE);
}

/**
 * Adds metadata callbacks for core entities to the entity info.
 */
function _entity_info_add_metadata_callbacks(&$entity_info) {
  // Set access callbacks.
  $entity_info['node']['access callback'] = 'entity_metadata_no_hook_node_access';
  $entity_info['user']['access callback'] = 'entity_metadata_user_access';

  // CRUD function callbacks.
  $entity_info['node']['creation callback'] = 'entity_metadata_create_node';
  $entity_info['node']['save callback'] = 'node_save';
  $entity_info['node']['deletion callback'] = 'node_delete';
  $entity_info['user']['creation callback'] = 'entity_metadata_create_object';
  $entity_info['user']['save callback'] = 'entity_metadata_user_save';
  $entity_info['user']['deletion callback'] = 'user_delete';
  $entity_info['file']['save callback'] = 'file_save';
  $entity_info['file']['deletion callback'] = 'entity_metadata_delete_file';

  // View callbacks.
  $entity_info['node']['view callback'] = 'entity_metadata_view_node';
  $entity_info['user']['view callback'] = 'entity_metadata_view_single';

  if (module_exists('comment')) {
    $entity_info['comment']['access callback'] = 'entity_metadata_comment_access';
    $entity_info['comment']['creation callback'] = 'entity_metadata_create_comment';
    $entity_info['comment']['save callback'] = 'comment_save';
    $entity_info['comment']['deletion callback'] = 'comment_delete';
    $entity_info['comment']['view callback'] = 'entity_metadata_view_comment';
  }
  if (module_exists('taxonomy')) {
    $entity_info['taxonomy_term']['access callback'] = 'entity_metadata_taxonomy_access';
    $entity_info['taxonomy_term']['creation callback'] = 'entity_metadata_create_object';
    $entity_info['taxonomy_term']['save callback'] = 'taxonomy_term_save';
    $entity_info['taxonomy_term']['deletion callback'] = 'taxonomy_term_delete';
    $entity_info['taxonomy_term']['view callback'] = 'entity_metadata_view_single';

    $entity_info['taxonomy_vocabulary']['access callback'] = 'entity_metadata_taxonomy_access';
    $entity_info['taxonomy_vocabulary']['creation callback'] = 'entity_metadata_create_object';
    $entity_info['taxonomy_vocabulary']['save callback'] = 'taxonomy_vocabulary_save';
    $entity_info['taxonomy_vocabulary']['deletion callback'] = 'taxonomy_vocabulary_delete';
    // Token type mapping.
    $entity_info['taxonomy_term']['token type'] = 'term';
    $entity_info['taxonomy_vocabulary']['token type'] = 'vocabulary';
  }
}
