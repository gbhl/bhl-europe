<?php

/**
 * @file
 *   Provides a content search implementation for node content for use with the
 *   Apache Solr search application.
 */

/**
 * Implementation of hook_help().
 */
function apachesolr_search_help($section) {
  switch ($section) {
    case 'admin/config/search/apachesolr/index':
      if (apachesolr_environment_variable_get(apachesolr_default_environment(), 'apachesolr_read_only', APACHESOLR_READ_WRITE) == APACHESOLR_READ_ONLY) {
        return t('Operating in read-only mode; updates are disabled.');
      }
      $remaining = 0;
      $total = 0;
      // Collect the stats
      $status = apachesolr_index_status('apachesolr_search');
      $remaining += $status['remaining'];
      $total += $status['total'];

      return t('The search index is generated by !cron. %percentage of the site content has been sent to the server. There @items left to send.', array(
        '!cron' => l(t('running cron'), 'admin/reports/status/run-cron', array('query' => array('destination' => 'admin/config/search/apachesolr/index'))),
        '%percentage' => ((int)min(100, 100 * ($total - $remaining) / max(1, $total))) . '%',
        '@items' => format_plural($remaining, t('is 1 item'), t('are @count items')
      )));
  }
}

/**
 * Implements hook_menu().
 */
function apachesolr_search_menu() {
  $items['admin/config/search/apachesolr/search-pages'] = array(
    'title'            => 'Search Pages',
    'description'      => t('Configure search pages.'),
    'page callback'    => 'apachesolr_search_page_list_page',
    'access arguments' => array('administer search'),
    'type'             => MENU_LOCAL_TASK,
    'file'             => 'apachesolr_search.admin.inc',
  );
  $items['admin/config/search/apachesolr/search-pages/add'] = array(
    'title'            => 'Add search page configuration',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('apachesolr_search_page_settings_form'),
    'access arguments' => array('administer search'),
    'type'             => MENU_LOCAL_ACTION,
    'file'             => 'apachesolr_search.admin.inc',
  );
  $items['admin/config/search/apachesolr/search-pages/%apachesolr_search_page/edit'] = array(
    'title' => 'Edit search page configuration',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('apachesolr_search_page_settings_form', 5),
    'access arguments' => array('administer search'),
    'file'             => 'apachesolr_search.admin.inc',
  );
  $items['admin/config/search/apachesolr/search-pages/%apachesolr_search_page/delete'] = array(
    'title'            => 'Delete search page configuration',
    'load arguments'   => array('apachesolr_search_page'),
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('apachesolr_search_delete_search_page_confirm', 5),
    'access arguments' => array('administer search'),
    'file'             => 'apachesolr_search.admin.inc',
  );
  $items['admin/config/search/apachesolr/query-fields'] = array(
    'title'            => 'Search fields',
    'page callback'    => 'apachesolr_search_settings_page',
    'access arguments' => array('administer search'),
    'weight'           => 1,
    'type'             => MENU_LOCAL_TASK,
    'file'             => 'apachesolr_search.admin.inc',
  );
  $items['admin/config/search/apachesolr/content-bias'] = array(
    'title'            => 'Content bias settings',
    'page callback'    => 'apachesolr_boost_settings_page',
    'access arguments' => array('administer search'),
    'weight'           => 1,
    'type'             => MENU_LOCAL_TASK,
    'file'             => 'apachesolr_search.admin.inc',
  );

  try {
    // Gets search pages directly from the index.
    // @todo Honor "enabled" settings?
    $result = db_select('apachesolr_search_page', 's')
      ->fields('s', array('page_id', 'search_path', 'page_title', 'env_id'))
      ->condition('env_id', '', '<>')
      ->execute();
  }
  catch (Exception $e) {
    watchdog_exception('apachesolr_search', $e);
    $result = array();
  }

  // Gets default search information.
  $default_info = search_get_default_module_info();

  // Iterates over search pages, builds menu items.
  foreach ($result as $record) {
    // Validate the environemnt ID in case of import or missed deletion.
    $environment = apachesolr_environment_load($record->env_id);
    if (!$environment) {
      continue;
    }
    // Parses search path into it's various parts, builds menu items dependent
    // on whether %keys is in the path.
    $parts = explode('/', $record->search_path);
    $keys_pos = count($parts);
    // Tests whether we are simulating a core search tab.
    $core_search = ($parts[0] == 'search');

    $items[$record->search_path] = array(
      'title' => $record->page_title,
      'page callback' => 'apachesolr_search_user_defined_search_page',
      'page arguments' => array($record->page_id, ''),
      'access arguments' => array('search content'),
      'type' => ($core_search) ? MENU_LOCAL_TASK : MENU_SUGGESTED_ITEM,
      'file' => 'apachesolr_search.pages.inc',
    );

    $items[$record->search_path . '/%menu_tail'] = array(
      'title' => $record->page_title,
      'load arguments' => array('%map', '%index'),
      'page callback' => 'apachesolr_search_user_defined_search_page',
      'page arguments' => array($record->page_id, $keys_pos),
      'access arguments' => array('search content'),
      'type' => MENU_LOCAL_TASK,
      'file' => 'apachesolr_search.pages.inc',
    );
    if ($core_search) {
      $items[$record->search_path . '/%menu_tail']['tab_root'] = 'search/' . $default_info['path'] . '/%';
      $items[$record->search_path . '/%menu_tail']['tab_parent'] = 'search/' . $default_info['path'];
    }
  }

  return $items;
}

function apachesolr_search_page_load($page_id) {
  $page = db_query('SELECT * FROM {apachesolr_search_page} s WHERE s.page_id = :page_id', array(':page_id' => $page_id))->fetchObject();
  if ($page) {
    $page->settings = unserialize($page->settings);
  }
  return $page; 
}

/**
 * Implements hook_cron(). Indexes nodes.
 */
function apachesolr_search_cron() {
  $cron_limit = variable_get('apachesolr_cron_limit', 50);
  $rows = apachesolr_get_nodes_to_index('apachesolr_search', $cron_limit);
  apachesolr_index_nodes($rows, 'apachesolr_search');
}

/**
 * Implements hook_apachesolr_types_exclude().
 */
function apachesolr_search_apachesolr_types_exclude($namespace) {
  if ($namespace == 'apachesolr_search') {
    $excluded_types = apachesolr_environment_variable_get(apachesolr_default_environment(), 'apachesolr_search_excluded_types', array());
    return array_filter($excluded_types);
  }
}

/**
 * Implementation of hook_search_info().
 */
function apachesolr_search_search_info() {
  return variable_get('apachesolr_search_search_info', array(
    'title' => 'Site',
    'path' => 'site',
    'conditions_callback' => 'apachesolr_search_conditions',
  ));
}

/**
 * Implementation of hook_search_reset().
 */
function apachesolr_search_search_reset() {
  apachesolr_clear_last_index('apachesolr_search');
}

/**
 * Implementation of hook_search_status().
 */
function apachesolr_search_search_status() {
  return apachesolr_index_status('apachesolr_search');
}

/**
 * Implementation of hook_search_execute().
 */
function apachesolr_search_search_execute($keys = NULL, $conditions = NULL) {
  $filters = isset($conditions['fq']) ? $conditions['fq'] : array();
  $solrsort = isset($_GET['solrsort']) ? $_GET['solrsort'] : '';
  $empty_search_behavior = isset($conditions['apachesolr_search_browse']) ? $conditions['apachesolr_search_browse'] : '';
  unset($conditions['apachesolr_search_browse']);

  try {
    if (!$keys && !$conditions && ($empty_search_behavior == 'browse' || $empty_search_behavior == 'blocks')) {
      // Pass empty search behavior as string on to apachesolr_search_search_page()
      apachesolr_search_run_empty('apachesolr', 'search/' . arg(1));
      $results['apachesolr_search_browse'] = $empty_search_behavior;
      if ($empty_search_behavior == 'browse') {
        // Hide sidebar blocks for content-area browsing instead.
        apachesolr_suppress_blocks(TRUE);
      }
    }
    else {
      $results = apachesolr_search_run('apachesolr', array('q' => $keys, 'fq' => $filters), $solrsort, 'search/' . arg(1), pager_find_page());
    }
    return $results;
  }
  catch (Exception $e) {
    watchdog('Apache Solr', nl2br(check_plain($e->getMessage())), NULL, WATCHDOG_ERROR);
    apachesolr_failure(t('Solr search'), $keys);
  }
}

/**
 * Implementation of a search_view() conditions callback.
 */
function apachesolr_search_conditions() {
  $conditions = array();

  if (!empty($_GET['fq']) && is_array($_GET['fq'])) {
    $conditions['fq'] = $_GET['fq'];
  }
  // We may also have filters added by facet API module. The 'f'
  // is determined by constant FacetapiAdapter::FILTER_KEY. Hard
  // coded here to avoid extra class loading.
  if (!empty($_GET['f']) && is_array($_GET['f'])) {
    if (module_exists('facetapi')) {
      $conditions['f'] = $_GET['f'];
    }
  }
  if (variable_get('apachesolr_search_browse', 'browse') != 'none') {
    // Set a condition so the search is triggered.
    $conditions['apachesolr_search_browse'] = variable_get('apachesolr_search_browse', 'browse');
  }
  return $conditions;
}

/**
 * Implements hook_search_page().
 */
function apachesolr_search_search_page($results) {
  if (!empty($results['apachesolr_search_browse'])) {
    // Show facet browsing blocks.
    $output = apachesolr_search_page_browse($results['apachesolr_search_browse']);
  }
  elseif ($results) {
    $output = array(
      '#theme' => 'search_results',
      '#results' => $results,
      '#module' => 'apachesolr_search',
    );
  }
  else {
    // Give the user some custom help text.
    $output = array('#markup' => theme('apachesolr_search_noresults'));
  }
  return $output;
}

/**
 * Implements hook_apachesolr_document_handlers().
 *
 * @param string $type
 *   Entity type. 'node', 'comment', and so forth. Used to evaluate whether this module
 *   should be interested in creating documents.
 * @param string $namespace
 *   Usually the name of the module that is initiating indexing. In this case
 *   we want to register a handler if the namespace is 'apachesolr_search'.
 * @return array $handlers
 *   An array of strings that are function names. Each function returns a $document from
 *   an entity (of type $type).
 */
function apachesolr_search_apachesolr_document_handlers($type, $namespace) {
  if ($type == 'node' && $namespace == 'apachesolr_search') {
    return array('apachesolr_node_to_document');
  }
}

/**
 * Handle browse results for empty searches.
 */
function apachesolr_search_page_browse($empty_search_behavior) {
  $build = array();

  // Switch in case we come up with new flags.
  switch ($empty_search_behavior) {
    case 'browse':
      if (module_exists('facetapi') && $query = apachesolr_current_query()) {
        module_load_include('inc', 'facetapi', 'facetapi.block');
        // Get facet render elements.
        $searcher = $query->getSearcher();
        $elements = facetapi_build_realm($searcher, 'block');
        $build = array();

        foreach (element_children($elements) as $key) {
          $delta = "facetapi_{$key}";
          // @todo: order/filter these pseudo-blocks according to block.module weight, visibility (see 7.x-1beta4)
          $block = new stdClass();
          $block->visibility = TRUE;
          $block->enabled = TRUE;
          $block->module = 'facetapi';
          $block->subject = check_plain($elements[$key]['#title']);
          $build[$delta] = $elements[$key];
          $block->region = NULL;
          $block->delta = 'apachesolr-' . $key;
          // @todo: the final themed block's div id attribute does not coincide with "real" block's id (see facetapi_get_delta_map())
          $build[$delta]['#block'] = $block;
          $build[$delta]['#theme_wrappers'][] = 'block';
          $build['#sorted'] = TRUE;
        }
        $build['#theme_wrappers'][] = 'apachesolr_search_browse_blocks';
      }
      break;
  }
  return $build;
}

/**
 * Shows a groups of blocks for starting a search from a filter.
 */
function theme_apachesolr_search_browse_blocks($vars) {
  $result = "<div class='apachesolr-browse-blocks'>\n<h2>" . t('Browse available categories') . "</h2>\n";
  $result .= '<p>' . t('Pick a category to launch a search.') . "</p>\n";
  $result .= $vars['content']['#children'] . "\n</div>\n";

  return $result;
}

/**
 * Execute a search with zero results rows so as to populate facets.
 */
function apachesolr_search_run_empty($name, $base_path = '') {
  $query = apachesolr_drupal_query($name, array(), '', $base_path);
  $query->addParam('rows', '0');
  list($final_query, $response) = apachesolr_do_query($query, 0);
  apachesolr_has_searched(TRUE);
}

/**
 * Execute a search results based on keyword, filter, and sort strings.
 *
 * @param $name
 * @param $params
 *   Array - 'q' is the keywords to search.
 * @param $solrsort
 * @param $base_path
 *   For constructing filter and sort links. Leave empty unless the links need to point somewhere
 *   other than the base path of the current request.
 * @param integer $page
 *   For pagination.
 * @param $caller
 *
 * @return stdClass $response
 *
 * @throws Exception
 */
function apachesolr_search_run($name, array $params = array(), $solrsort = '', $base_path = '', $page = 0, $solr = NULL) {
  // This is the object that knows about the query coming from the user.
  $query = apachesolr_drupal_query($name, $params, $solrsort, $base_path, $solr);

  apachesolr_search_basic_params($query);
  apachesolr_search_add_boost_params($query);
  if ($query->getParam('q')) {
    apachesolr_search_highlighting_params($query);
    if (!$query->getParam('hl.fl')) {
      $qf = array();
      foreach ($query->getParam('qf') as $field) {
        // Truncate off any boost so we get the simple field name.
        $parts = explode('^', $field, 2);
        $qf[$parts[0]] = TRUE;
      }
      foreach (array('content', 'ts_comments') as $field) {
        if (isset($qf[$field])) {
          $query->addParam('hl.fl', $field);
        }
      }
    }
    apachesolr_search_add_spellcheck_params($query);
  }
  else {
    // No highlighting, use the teaser as a snippet.
    $query->addParam('fl', 'teaser');
  }
  list($final_query, $response) = apachesolr_do_query($query, $page);
  apachesolr_has_searched(TRUE);

  return apachesolr_search_process_response($response, $final_query);
}


function apachesolr_search_basic_params(DrupalSolrQueryInterface $query = NULL) {
  $params = array(
    'fl' => array('id', 'entity_id', 'entity_type', 'bundle', 'bundle_name', 'label', 'is_comment_count', 'ds_created', 'ds_changed', 'score', 'path', 'url', 'is_uid', 'tos_name'),
    'rows' => variable_get('apachesolr_rows', 10),
  );
  if ($query) {
    $query->addParams($params);
  }
  return $params;
}

/**
 * Add highlighting settings to the search params.
 *
 * These settings are set in solrconfig.xml.
 * See the defaults there.
 * If you wish to override them, you can via settings.php or drush
 */
function apachesolr_search_highlighting_params(DrupalSolrQueryInterface $query = NULL) {
  $params['hl'] = variable_get('apachesolr_hl_active', NULL);
  $params['hl.fragsize']= variable_get('apachesolr_hl_textsnippetlength', NULL);
  $params['hl.simple.pre'] = variable_get('apachesolr_hl_pretag', NULL);
  $params['hl.simple.post'] = variable_get('apachesolr_hl_posttag', NULL);
  $params['hl.snippets'] = variable_get('apachesolr_hl_numsnippets', NULL);
  // This should be an array of possible field names.
  $params['hl.fl'] = variable_get('apachesolr_hl_fieldtohighlight', NULL);
  $params = array_filter($params);
  if ($query) {
    $query->addParams($params);
  }
  return $params;
}

function apachesolr_search_add_spellcheck_params(DrupalSolrQueryInterface $query) {
  $params = array();
  if (variable_get('apachesolr_search_spellcheck', TRUE)) {
    //Add new parameter to the search request
    $params['spellcheck.q'] = $query->getParam('q');
    $params['spellcheck'] = 'true';
  }
  $query->addParams($params);
}

function apachesolr_search_add_boost_params(DrupalSolrQueryInterface $query) {
  $env_id = $query->solr('getId');
  $params = array();

  $defaults = array(
    'content' => '1.0',
    'ts_comments' => '0.5',
    'tos_content_extra' => '0.1',
    'label' => '5.0',
    'tos_name' => '3.0',
    'taxonomy_names' => '2.0',
    'tags_h1' => '5.0',
    'tags_h2_h3' => '3.0',
    'tags_h4_h5_h6' => '2.0',
    'tags_inline' => '1.0',
    'tags_a' => '0',
  );
  $qf = apachesolr_environment_variable_get($env_id, 'apachesolr_search_query_fields', $defaults);
  $fields = $query->solr('getFields');
  if ($qf && $fields) {
    foreach ($fields as $field_name => $field) {
      if (!empty($qf[$field_name])) {
        $prefix = substr($field_name, 0, 3);
        if ($field_name == 'content' || $prefix == 'ts_' || $prefix == 'tm_') {
          // Normed fields tend to have a lower score. Multiplying by 40 is
          // a rough attempt to bring the score in line with fields that are
          // not normed.
          $qf[$field_name] *= 40.0;
        }
        $params['qf'][$field_name] = $field_name . '^' . $qf[$field_name];
      }
    }
  }

  $date_settings = apachesolr_environment_variable_get($env_id, 'apachesolr_search_date_boost', '0:0');
  $comment_settings = apachesolr_environment_variable_get($env_id, 'apachesolr_search_comment_boost', '0:0');
  $changed_settings = apachesolr_environment_variable_get($env_id, 'apachesolr_search_changed_boost', '0:0');
  $sticky_boost = apachesolr_environment_variable_get($env_id, 'apachesolr_search_sticky_boost', '0');
  $promote_boost = apachesolr_environment_variable_get($env_id, 'apachesolr_search_promote_boost', '0');
  // For the boost functions for the created timestamp, etc we use the
  // standard date-biasing function, as suggested (but steeper) at
  // http://wiki.apache.org/solr/SolrRelevancyFAQ#How_can_I_boost_the_score_of_newer_documents
  // ms() returns the time difference in ms between now and the date
  // The function is thus: $ab/(ms(NOW,date)*$steepness + $ab).
  list($date_steepness, $date_boost) = explode(':', $date_settings);
  if ($date_boost) {
    $ab = 4 / $date_steepness;
    $params['bf'][] = "recip(ms(NOW,ds_created),3.16e-11,$ab,$ab)^$date_boost";
  }
  // Boost on comment count.
  list($comment_steepness, $comment_boost) = explode(':', $comment_settings);
  if ($comment_boost) {
    $params['bf'][] = "recip(div(1,max(is_comment_count,1)),$comment_steepness,10,10)^$comment_boost";
  }
  // Boost for a more recent comment or node edit.
  list($changed_steepness, $changed_boost) = explode(':', $changed_settings);
  if ($changed_boost) {
    $ab = 4 / $changed_steepness;
    $params['bf'][] = "recip(ms(NOW,ds_created),3.16e-11,$ab,$ab)^$changed_boost";
  }
  // Boost for nodes with sticky bit set.
  if ($sticky_boost) {
    $params['bq'][] = "bs_sticky:true^$sticky_boost";
  }
  // Boost for nodes with promoted bit set.
  if ($promote_boost) {
    $params['bq'][] = "bs_promote:true^$promote_boost";
  }
  // Modify the weight of results according to the node types.
  $type_boosts = apachesolr_environment_variable_get($env_id, 'apachesolr_search_type_boosts', array());
  if (!empty($type_boosts)) {
    foreach ($type_boosts as $type => $boost) {
      // Only add a param if the boost is != 0 (i.e. > "Normal").
      if ($boost) {
        $params['bq'][] = "bundle:$type^$boost";
      }
    }
  }
  $query->addParams($params);
}

function apachesolr_search_process_response($response, DrupalSolrQueryInterface $query) {
  $results = array();
  // We default to getting snippets from the body content and comments.
  $hl_fl = $query->getParam('hl.fl');
  if (!$hl_fl) {
    $hl_fl = array('content', 'ts_comments');
  }
  $total = $response->response->numFound;
  pager_default_initialize($total, $query->getParam('rows'));
  if ($total > 0) {
    foreach ($response->response->docs as $doc) {
      $extra = array();

      // Start with an empty snippets array.
      $snippets = array();

      // Find the nicest available snippet.
      foreach ($hl_fl as $hl_param) {
        if (isset($response->highlighting->{$doc->id}->$hl_param)) {
          // Merge arrays preserving keys.
          foreach ($response->highlighting->{$doc->id}->$hl_param as $values) {
            $snippets[$hl_param] = $values;
          }
        }
      }
      // If there's no snippet at this point, add the teaser.
      if (!$snippets) {
        if (isset($doc->teaser)) {
          $snippets[] = truncate_utf8($doc->teaser, 256, TRUE);
        }
      }
      $snippet = theme('apachesolr_search_snippets__' . $doc->entity_type . '__' . $doc->bundle, array('doc' => $doc, 'snippets' => $snippets));

      if (!isset($doc->content)) {
        $doc->content = $snippet;
      }

      // Normalize common dates so that we can use Drupal's normal date and
      // time handling.
      if (isset($doc->ds_created)) {
        $doc->created = strtotime($doc->ds_created);
      }
      if (isset($doc->ds_changed)) {
        $doc->changed = strtotime($doc->ds_changed);
      }
      if (isset($doc->tos_name)) {
        $doc->name = $doc->tos_name;
      }

      $extra = array();

      // Allow modules to alter each document and its extra information.
      drupal_alter('apachesolr_search_result', $doc, $extra);

      $fields = (array) $doc;

      $result = array(
        // link is a required field, so handle it centrally.
        'link' => url($doc->path, array('absolute' => TRUE)),
        // template_preprocess_search_result() runs check_plain() on the title
        // again.  Decode to correct the display.
        'title' => htmlspecialchars_decode($doc->label, ENT_QUOTES),
        // These values are not required by the search module but are provided
        // to give entity callbacks and themers more flexibility.
        'score' => $doc->score,
        'snippets' => $snippets,
        'snippet' => $snippet,
        'fields' => $fields,
        'entity_type' => $doc->entity_type,
        'bundle' => $doc->bundle,
      );

      // Call entity-type-specific callbacks for extra handling.
      $function = apachesolr_entity_get_callback($doc->entity_type, 'result callback');
      if (function_exists($function)) {
        $function($doc, $result, $extra);
      }

      $result['extra'] = $extra;

      $results[] = $result;
    }

    // Hook to allow modifications of the retrieved results
    foreach (module_implements('apachesolr_process_results') as $module) {
      $function = $module . '_apachesolr_process_results';
      $function($results);
    }
  }
  return $results;
}

/**
 * Implements hook_entity_info_alter().
 */
function apachesolr_search_entity_info_alter(&$entity_info) {

  // First set defaults so that we needn't worry about NULL keys.
  foreach (array_keys($entity_info) as $type) {
    $entity_info[$type] += array('apachesolr' => array());
    $entity_info[$type]['apachesolr'] += array(
      'result callback' => '',
    );
  }

  // Now set those values that we know.  Other modules can do so
  // for their own entities if they want.
  $entity_info['node']['apachesolr']['result callback'] = 'apachesolr_search_node_result';
}

/**
 * Callback function for node search results.
 *
 * @param stdClass $doc
 *   The result document from Apache Solr.
 * @param array $result
 *   The result array for this record to which to add.
 */
function apachesolr_search_node_result($doc, &$result, &$extra) {
  $doc->uid = $doc->is_uid;
  $result += array(
    'type' => node_type_get_name($doc->bundle),
    'user' => theme('username', array('account' => $doc)),
    'date' => isset($doc->changed) ? $doc->changed : 0,
    'node' => $doc,
    'uid' => $doc->is_uid,
  );

  if (isset($doc->is_comment_count)) {
    $extra['comments'] = format_plural($doc->is_comment_count, '1 comment', '@count comments');
  }
}

/**
 * Returns whether a search page exists. 
 */
function apachesolr_search_page_exists($search_page_id) {
  return db_query('SELECT 1 FROM {apachesolr_search_page} WHERE page_id = :page_id', array(':page_id' => $search_page_id))->fetchField();
}

/**
 * Template preprocess for apachesolr search results.
 *
 * We need to add additional entity/bundle-based templates
 */
function apachesolr_search_preprocess_search_result(&$variables) {
  // If this search result is coming from our module, we want to improve the
  // template potential to make life easier for themers.
  if ($variables['module'] == 'apachesolr_search') {
    $result = $variables['result'];
    $variables['theme_hook_suggestions'][] = 'search_result__' . $variables['module'] . '__' . $result['entity_type'] . '__' . $result['bundle'];
  }
}

function apachesolr_search_preprocess_search_results(&$variables) {
  // If this is a solr search, expose more data to themes to play with.
  if ($variables['module'] == 'apachesolr_search') {
    $query = apachesolr_current_query();
    if ($query) {
      $variables['query'] = $query;
      $variables['response'] = apachesolr_static_response_cache($query->getSearcher());
    }
    if (empty($variables['response'])) {
      $variables['description'] = '';
      return;
    }
    $total = $variables['response']->response->numFound;
    $params = $variables['query']->getParams();

    $variables['description'] = t('Showing items @start through @end of @total.', array(
      '@start' => $params['start'] + 1,
      '@end' => $params['start'] + $params['rows'] - 1,
      '@total' => $total,
    ));
  }
}

function apachesolr_search_date_range(DrupalSolrQueryInterface $query, $facet_field) {
  foreach ($query->get_filters($facet_field) as $filter) {
    // If we had an ISO date library we could use ISO dates
    // directly.  Instead, we convert to Unix timestamps for comparison.
    // Only use dates if we are able to parse into timestamps.
    $start = strtotime($filter['#start']);
    $end = strtotime($filter['#end']);
    if ($start && $end && ($start < $end)) {
        $start_iso = $filter['#start'];
        $end_iso = $filter['#end'];
      // Determine the drilldown gap for this range.
      $gap = apachesolr_date_gap_drilldown(apachesolr_date_find_query_gap($start_iso, $end_iso));
    }
  }
  // If there is no $delta field in query object, get initial
  // facet.date.* params from the DB and determine the best search
  // gap to use. This callback assumes $facet_field is 'ds_changed' or
  // 'ds_created'.
  switch ($facet_field) {
    case 'ds_created' :
      $field = 'created';
      break;
    case 'ds_changed' :
      $field = 'changed';
      break;
  }
  if (!isset($start_iso)) {
    $start_iso = apachesolr_date_iso(db_query("SELECT MIN($field) FROM {node} WHERE status = 1")->fetchField());
    // Subtract one second, so that this range's $end_iso is not equal to the
    // next range's $start_iso.
    $end_iso = apachesolr_date_iso(db_query("SELECT MAX($field) FROM {node} WHERE status = 1")->fetchField() - 1);
    $gap = apachesolr_date_determine_gap($start_iso, $end_iso);
  }
  // Return a query range from the beginning of a gap period to the beginning
  // of the next gap period.  We ALWAYS generate query ranges of this form
  // and the apachesolr_date_*() helper functions require it.
  return array("$start_iso/$gap", "$end_iso+1$gap/$gap", "+1$gap");
}

/**
 * Helper function, finds node types that are tagged by the specified vocabulary
 */

function apachesolr_search_vocabulary_content_types($vid) {
  $fields = field_info_fields();
  $types = array();
  foreach (field_info_instances('node') as $bundle_name => $bundle) {
    foreach ($bundle as $field_name => $inst) {
      $f = $fields[$field_name];
      if ($f['type'] == 'taxonomy_term_reference' && $f['settings']['allowed_values'][0]['vid'] == $vid) {
        $types[] = $bundle_name;
      }
    }
  }
  return array_unique($types);
}

/**
 * Implements hook_apachesolr_environment_delete().
 */
function apachesolr_search_apachesolr_environment_delete($server) {
  db_update('apachesolr_search_page')
    ->fields(array(
      'env_id' => '',
    ))
    ->condition('env_id', $server['env_id'])
    ->execute();

  menu_rebuild();
}

/**
 * Implements hook_form_[form_id]_alter().
 *
 * This adds spelling suggestions, retain filters to the search form.
 */
function apachesolr_search_form_search_form_alter(&$form, $form_state) {
  if ($form['module']['#value'] == 'apachesolr_search') {
    $form['#submit'][] = 'apachesolr_search_form_search_submit';
    // No other modification make sense unless a query is active.
    // Note - this means that the query must always be run before
    // calling drupal_get_form('search_form').
    $apachesolr_has_searched = apachesolr_has_searched();

    $searcher = NULL;
    $fq = NULL;
    if ($apachesolr_has_searched) {
      $query = apachesolr_current_query();
      $searcher = $query->getSearcher();
      // We use the presence of filter query params as a flag for the retain filters checkbox.
      $fq = $query->getParam('fq');
    }

    $form['basic']['apachesolr_search']['#tree'] = TRUE;
    $form['basic']['apachesolr_search']['get'] = array(
      '#type' => 'hidden',
      '#default_value' => json_encode(array_diff_key($_GET, array('q' => 1, 'page' => 1, 'solrsort' => 1, 'retain-filters' => 1))),
    );

    if ($fq || isset($form_state['input']['apachesolr_search']['retain-filters'])) {
      $form['basic']['apachesolr_search']['retain-filters'] = array(
        '#type' => 'checkbox',
        '#title' => t('Retain current filters'),
        '#default_value' => (int) isset($_GET['retain-filters']),
      );
    }

    if (variable_get('apachesolr_search_spellcheck', TRUE) && $apachesolr_has_searched && ($response = apachesolr_static_response_cache($searcher))) {
      // Get spellchecker suggestions into an array.
      if (isset($response->spellcheck->suggestions) && $response->spellcheck->suggestions) {
        $suggestions = get_object_vars($response->spellcheck->suggestions);
        if ($suggestions) {
          // Get the original query and replace words.

          foreach ($suggestions as $word => $value) {
            $replacements[$word] = $value->suggestion[0];
          }
          $new_keywords = strtr($query->getParam('q'), $replacements);

          // Show only if suggestion is different than current query.
          if ($query->getParam('q') != $new_keywords) {
            $form['apachesolr_search']['suggestion'] = array(
              '#theme' => 'apachesolr_search_suggestions',
              '#links' => array(l($new_keywords, $query->getPath($new_keywords))),
            );
          }
        }
      }
    }
  }
}

/**
 * Default theme function for spelling suggestions.
 */
function theme_apachesolr_search_suggestions($variables) {
  $output = '<div class="spelling-suggestions">';
  $output .= '<dl class="form-item"><dt><strong>' . t('Did you mean') . '</strong></dt>';
  foreach ((array) $variables['links'] as $link) {
    $output .= '<dd>' . $link . '</dd>';
  }
  $output .= '</dl></div>';
  return $output;
}

/**
 * Added form submit function to retain filters.
 *
 * @see apachesolr_search_form_search_form_alter()
 */
function apachesolr_search_form_search_submit($form, &$form_state) {
  $fv = $form_state['values'];
  $get = json_decode($fv['apachesolr_search']['get'], TRUE);
  if (!empty($fv['apachesolr_search']['retain-filters'])) {
    $get['retain-filters'] = '1';
    // Add the query values into the redirect.
    $form_state['redirect'] = array($form_state['redirect'], array('query' => $get));
  }
}

/**
 * Implements hook_form_[form_id]_alter().
 *
 * This adds options to the apachesolr admin form.
 */
function apachesolr_search_form_apachesolr_settings_alter(&$form, $form_state) {
  module_load_include('inc', 'apachesolr_search', 'apachesolr_search.admin');
  $form['apachesolr_search_browse'] = _apachesolr_search_browse_form(variable_get('apachesolr_search_browse', 'browse'));

  $form['apachesolr_search_spellcheck'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable spellchecker and suggestions'),
    '#default_value' => variable_get('apachesolr_search_spellcheck', TRUE),
    '#description' => t('Enable spellchecker and get word suggestions. Also known as the "Did you mean ... ?" feature.'),
  );

  $form['#submit'][] = 'apachesolr_search_build_spellcheck';

  if (isset($form['buttons'])) {
    // Move buttons to the bottom.
    $buttons = $form['buttons'];
    unset($form['buttons']);
    $form['buttons'] = $buttons;
  }
}

/**
 * Implements hook_form_[form_id]_alter().
 *
 * Rebuild (empty) the spellcheck dictionary when the index is deleted..
 */
function apachesolr_search_form_apachesolr_delete_index_form_alter(&$form, $form_state) {
  $form['submit']['#submit'][] = 'apachesolr_search_build_spellcheck';
}

function apachesolr_search_build_spellcheck($form, &$form_state) {
  try {
    $solr = apachesolr_get_solr();
    $params['spellcheck'] = 'true';
    $params['spellcheck.build'] = 'true';
    $response = $solr->search('solr', 0, 0, $params);
  }
  catch (Exception $e) {
    watchdog('Apache Solr', nl2br(check_plain($e->getMessage())), NULL, WATCHDOG_ERROR);
  }
}

/**
 * Implements hook_theme().
 */
function apachesolr_search_theme() {
  return array(
    'apachesolr_search_browse_blocks' => array(
      'render element' => 'content',
    ),
    'apachesolr_search_snippets' => array(
      'variables' => array('doc' => NULL, 'snippets' => array()),
    ),
    'apachesolr_search_noresults' => array(
      'variables' => array(),
    ),
    'apachesolr_search_suggestions' => array(
      'variables' => array('links' => NULL),
    ),
  );
}

/**
 * Proxy theme function for 'created' and 'changed' date fields.
 */
function theme_apachesolr_breadcrumb_date_range($vars) {
  $field = $vars['field'];
  if (preg_match('@[\[\{](\S+) TO (\S+)[\]\}]@', $field['#value'], $match)) {
    return apachesolr_date_format_range($match[1], $match[2]);
  }
  return $field['#value'];
}

/**
 * Theme the highlighted snippet text for a search entry.
 *
 * @param array $vars
 *
 */
function theme_apachesolr_search_snippets($vars) {
  $result = '';
  if (is_array($vars['snippets'])) {
    $snippets = $vars['snippets'];
    if (isset($snippets['content'])) {
      $result .= $snippets['content'];
      unset($snippets['content']);
    }
    if (isset($snippets['teaser'])) {
      $result .= (strlen($result) > 0) ? ' ... ' : '';
      $result .= $snippets['teaser'];
      unset($snippets['teaser']);
    }
    $result .= (strlen($result) > 0) ? ' ... ' : '';
    $result .= implode(' ... ', $snippets);
  }
  return $result . ' ...';
}

/**
 * Brief message to display when no results match the query.
 *
 * @see search_help()
 */
function theme_apachesolr_search_noresults() {
  return t('<ul>
<li>Check if your spelling is correct, or try removing filters.</li>
<li>Remove quotes around phrases to match each word individually: <em>"blue drop"</em> will match less than <em>blue drop</em>.</li>
<li>You can require or exclude terms using + and -: <em>big +blue drop</em> will require a match on <em>blue</em> while <em>big blue -drop</em> will exclude results that contain <em>drop</em>.</li>
</ul>');
}



