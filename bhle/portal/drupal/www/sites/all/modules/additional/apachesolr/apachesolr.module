<?php

/**
 * @file
 *   Integration with the Apache Solr search application.
 */

define('APACHESOLR_READ_WRITE', 0);
define('APACHESOLR_READ_ONLY', 1);
define('APACHESOLR_API_VERSION', '3.0');

/**
 * Implements hook_menu().
 */
function apachesolr_menu() {
  $items = array();
  $items['admin/config/search/apachesolr'] = array(
    'title'              => 'Apache Solr search',
    'description'        => 'Administer Apache Solr.',
    'page callback'      => 'drupal_get_form',
    'page arguments'     => array('apachesolr_settings'),
    'access arguments'   => array('administer search'),
    'weight'             => -9,
    'file'               => 'apachesolr.admin.inc',
  );
  $items['admin/config/search/apachesolr-env/%apachesolr_environment'] = array(
    'title'              => 'Apache Solr search environment edit',
    'description'        => 'Edit Apache Solr search environment.',
    'page callback'      => 'drupal_get_form',
    'page arguments'     => array('apachesolr_environment_edit_form', 4),
    'access arguments'   => array('administer search'),
    'file'               => 'apachesolr.admin.inc',
    'type'               => MENU_CALLBACK,
  );
  $items['admin/config/search/apachesolr-env/%apachesolr_environment/edit'] = array(
    'title'              => 'Edit',
    'weight'             => -20,
    'type'               => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/config/search/apachesolr-env/%apachesolr_environment/delete'] = array(
    'title'              => 'Apache Solr search environment delete',
    'page callback'      => 'apachesolr_environment_delete_page',
    'page arguments'     => array(4),
    'access arguments'   => array('administer search'),
    'file'               => 'apachesolr.admin.inc',
    'type'               => MENU_CALLBACK,
  );
  $items['admin/config/search/apachesolr-env/add'] = array(
    'title'              => 'Apache Solr search environment add',
    'description'        => 'Add Apache Solr environment.',
    'page callback'      => 'drupal_get_form',
    'page arguments'     => array('apachesolr_environment_edit_form', NULL),
    'access arguments'   => array('administer search'),
    'file'               => 'apachesolr.admin.inc',
    'type'               => MENU_CALLBACK,
  );
  $items['admin/config/search/apachesolr/settings'] = array(
    'title'              => 'Settings',
    'weight'             => -10,
    'access arguments'   => array('administer search'),
    'file'               => 'apachesolr.admin.inc',
    'type'               => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/config/search/apachesolr/index'] = array(
    'title'              => 'Search index',
    'page callback'      => 'apachesolr_index_page',
    'access arguments'   => array('administer search'),
    'weight'             => -8,
    'file'               => 'apachesolr.admin.inc',
    'type'               => MENU_LOCAL_TASK,
  );
  $items['admin/config/search/apachesolr/index/confirm/clear'] = array(
    'title'              => 'Confirm the re-indexing of all content',
    'page callback'      => 'drupal_get_form',
    'page arguments'     => array('apachesolr_clear_index_confirm'),
    'access arguments'   => array('administer search'),
    'file'               => 'apachesolr.admin.inc',
    'type'               => MENU_CALLBACK,
  );
  $items['admin/config/search/apachesolr/index/confirm/delete'] = array(
    'title'              => 'Confirm index deletion',
    'page callback'      => 'drupal_get_form',
    'page arguments'     => array('apachesolr_delete_index_confirm'),
    'access arguments'   => array('administer search'),
    'file'               => 'apachesolr.admin.inc',
    'type'               => MENU_CALLBACK,
  );
  $items['admin/reports/apachesolr'] = array(
    'title'              => 'Apache Solr search index',
    'description'        => 'Infromation about the contents of the index the server',
    'page callback'      => 'apachesolr_index_report',
    'access arguments'   => array('access site reports'),
    'file'               => 'apachesolr.admin.inc',
  );
  $items['admin/reports/apachesolr/index'] = array(
    'title'              => 'Search index',
    'file'               => 'apachesolr.admin.inc',
    'type'               => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/reports/apachesolr/conf'] = array(
    'title'              => 'Configuration files',
    'page callback'      => 'apachesolr_config_files_overview',
    'access arguments'   => array('access site reports'),
    'file'               => 'apachesolr.admin.inc',
    'weight'             => 5,
    'type'               => MENU_LOCAL_TASK,
  );
  $items['admin/reports/apachesolr/conf/%'] = array(
    'title'              => 'Configuration file',
    'page callback'      => 'apachesolr_config_file',
    'page arguments'     => array(4),
    'access arguments'   => array('access site reports'),
    'file'               => 'apachesolr.admin.inc',
    'type'               => MENU_CALLBACK,
  );
  $items['admin/config/search/apachesolr/mlt/add_block'] = array(
    'title'              => 'Add a new content recommendation block',
    'page callback'      => 'drupal_get_form',
    'page arguments'     => array('apachesolr_mlt_add_block_form'),
    'access arguments'   => array('administer search'),
    'file'               => 'apachesolr.admin.inc',
    'type'               => MENU_LOCAL_ACTION,
  );
  $items['admin/config/search/apachesolr/mlt/delete_block/%'] = array(
    'page callback'      => 'drupal_get_form',
    'page arguments'     => array('apachesolr_mlt_delete_block_form', 5),
    'access arguments'   => array('administer search'),
    'file'               => 'apachesolr.admin.inc',
    'type'               => MENU_CALLBACK,
  );

  // We handle our own menu paths for facets
  if (module_exists('facetapi')) {
    $file_path = drupal_get_path('module', 'facetapi');
    $base_path = 'admin/config/search/apachesolr';
    $first = TRUE;
    foreach (facetapi_get_realm_info() as $realm_name => $realm) {
      if ($first) {
        $first = FALSE;
        $items[$base_path . '/facets'] = array(
          'title'            => 'Enabled filters',
          'page callback'    => 'apachesolr_enabled_facets_page',
          'page arguments'   =>  array($realm_name, NULL),
          'weight'           => -7,
          'access arguments' => array('administer search'),
          'file path'        => $file_path,
          'file'             => 'facetapi.admin.inc',
          'type'             => MENU_LOCAL_TASK,
          'context'          => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
        );
        $items[$base_path . '/facets/' . $realm_name] = array(
          'title'            => $realm['label'],
          'type'             => MENU_DEFAULT_LOCAL_TASK,
          'weight'           => $realm['weight'],
        );
        $items[$base_path . '-env/%apachesolr_environment/facets'] = $items[$base_path . '/facets'];
        $items[$base_path . '-env/%apachesolr_environment/facets']['page arguments'] = array($realm_name, 4);
      }
      else {
        $items[$base_path . '/facets/' . $realm_name] = array(
          'title'            => $realm['label'],
          'page callback'    => 'apachesolr_enabled_facets_page',
          'page arguments'   => array($realm_name, NULL),
          'access arguments' => array('administer search'),
          'type'             => MENU_LOCAL_TASK,
          'context'          => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
          'file path'        => $file_path,
          'file'             => 'facetapi.admin.inc',
        );
      }
      $items[$base_path . '-env/%apachesolr_environment/facets/' . $realm_name] = $items[$base_path . '/facets/' . $realm_name];
      $items[$base_path . '-env/%apachesolr_environment/facets/' . $realm_name]['page arguments'] = array($realm_name, 4);
    }
  }
  return $items;
}

/**
 * Wrapper for facetapi settings forms.
 */
function apachesolr_enabled_facets_page($realm_name, $environment = NULL) {
  $page = array();

  if (isset($environment['env_id'])) {
    $env_id = $environment['env_id'];
  }
  else {
    $env_id = apachesolr_default_environment();
  }
  $searcher = 'apachesolr@' . $env_id;

  // Initializes output with information about which environment's setting we are
  // editing, as it is otherwise not transparent to the end user.
  $page['apachesolr_environment'] = array(
    '#theme' => 'apachesolr_settings_title',
    '#env_id' => $env_id,
  );
  $page['settings'] = drupal_get_form('facetapi_realm_settings_form', $searcher, $realm_name);
  return $page;
}

/**
 * Implements hook_init().
 */
function apachesolr_init() {
  if (arg(0) == 'admin') {
    // Add the CSS for this module
    drupal_add_css(drupal_get_path('module', 'apachesolr') . '/apachesolr.css');
  }
}

/**
 * Implements hook_facetapi_searcher_info().
 */
function apachesolr_facetapi_searcher_info() {
  $info = array();
  foreach (apachesolr_load_all_environments() as $id => $environment) {
    $info['apachesolr@' . $id] = array(
      'label' => t('Apache Solr environment: @environment', array('@environment' => $environment['name'])),
      'adapter' => 'apachesolr',
      'instance' => $id,
      'path' => '',
      'supports facet missing' => TRUE,
    );
  }
  return $info;
}

/**
 * Implements hook_facetapi_adapters().
 */
function apachesolr_facetapi_adapters() {
  return array(
    'apachesolr' => array(
      'handler' => array(
        'class' => 'ApacheSolrFacetapiAdapter',
      ),
    ),
  );
}

/**
 * Implements hook_facetapi_query_types().
 */
function apachesolr_facetapi_query_types() {
  return array(
    'apachesolr_term' => array(
      'handler' => array(
        'class' => 'ApacheSolrFacetapiTerm',
        'adapter' => 'apachesolr',
      ),
    ),
    'apachesolr_date' => array(
      'handler' => array(
        'class' => 'ApacheSolrFacetapiDate',
        'adapter' => 'apachesolr',
      ),
    ),
  );
}

/**
 * Implements hook_facetapi_facet_info().
 */
function apachesolr_facetapi_facet_info($searcher_info) {
  $facets = array();
  if ('apachesolr' == $searcher_info['adapter']) {
    foreach (apachesolr_entity_fields('node') as $field_nm => $field_info) {
      if ($field_info['facets']) {
        $field = apachesolr_index_key($field_info);
        $facets[$field] = array(
          'label' => check_plain($field_info['display_name']),
          'dependency plugins' => $field_info['dependency plugins'],
          'field api name' => $field_info['field']['field_name'],
          'description' => t('Filter by field of type @type.', array('@type' => $field_info['field']['type'])),
          'map callback' => $field_info['map callback'],
          'map options' => $field_info,
          'hierarchy callback' => $field_info['hierarchy callback'],
          'facet missing allowed' => $field_info['facet missing allowed'],
        );
      }
    }
  }
  return $facets;
}

/**
 * Implements hook_facetapi_facet_info_alter().
 */
function apachesolr_facetapi_facet_info_alter(&$facet_info, $searcher_info) {
  // Provide information about the real Solr field names for these default facets.
  if ('apachesolr' == $searcher_info['adapter']) {
    $facet_info['author']['field'] = 'is_uid';
    $facet_info['language']['field'] = 'ss_language';
    $facet_info['created']['field'] = 'ds_created';
    $facet_info['changed']['field'] = 'ds_changed';
  }
}

/**
 * Determines Apache Solr's behavior when searching causes an exception (e.g. Solr isn't available.)
 * Depending on the admin settings, possibly redirect to Drupal's core search.
 *
 * @param $search_name
 *   The name of the search implementation.
 *
 * @param $querystring
 *   The search query that was issued at the time of failure.
 */
function apachesolr_failure($search_name, $querystring) {
  $fail_rule = variable_get('apachesolr_failure', 'apachesolr:show_error');

  switch ($fail_rule) {
    case 'apachesolr:show_error':
      drupal_set_message(t('The Apache Solr search engine is not available. Please contact your site administrator.'), 'error');
      break;
    case 'apachesolr:show_no_results':
      // Do nothing.
      break;
    default:
      // If we're failing over to another module make sure the search is available.
      $search_info = search_get_info();
      if (isset($search_info[$fail_rule])) {
        $search_info = $search_info[$fail_rule];
        drupal_set_message(t("%search_name is not available. Your search is being redirected.", array('%search_name' => $search_name)));
        drupal_goto('search/' . $search_info['path'] . '/' . drupal_encode_path($querystring));
      }
      break;
  }
}

/**
 * Like $site_key in _update_refresh() - returns a site-specific hash.
 */
function apachesolr_site_hash() {
  if (!($hash = variable_get('apachesolr_site_hash', FALSE))) {
    global $base_url;
    // Set a random 6 digit base-36 number as the hash.
    $hash = substr(base_convert(sha1(uniqid($base_url, TRUE)), 16, 36), 0, 6);
    variable_set('apachesolr_site_hash', $hash);
  }
  return $hash;
}

/**
 * Generate a unique ID for an entity being indexed.
 *
 * @param $id
 *   An id number (or string) unique to this site, such as a node ID.
 * @param $entity
 *   A string like 'node', 'file', 'user', or some other Drupal object type.
 *
 * @return
 *   A string combining the parameters with the site hash.
 */
function apachesolr_document_id($id, $entity = 'node') {
  return apachesolr_site_hash() . "/$entity/" . $id;
}

/**
 * Implements hook_user().
 *
 * Mark nodes as needing re-indexing if the author name changes.
 */
function apachesolr_user_update(&$edit, $account, $category) {
  if (isset($edit['name']) && $account->name != $edit['name']) {
    // TODO: performance issue. see http://drupal.org/node/592522
    $nid_query = db_select('node')->fields('node', array('nid'))->where("uid = :uid", array(':uid' => $account->uid));
    db_update('apachesolr_search_node')->condition('nid', $nid_query, 'IN')->fields(array('changed' => REQUEST_TIME))->execute();
  }
}

/**
 * Implements hook_taxonomy().
 *
 * Mark nodes as needing re-indexing if a term name changes.
 */
function apachesolr_taxonomy_term_update($term) {
  // TODO: performance issue. see http://drupal.org/node/592522
  $nid_query = db_select('taxonomy_index')->fields('taxonomy_index', array('nid'))->where("tid = :tid", array(':tid' => $term->tid));
  db_update('apachesolr_search_node')->condition('nid', $nid_query, 'IN')->fields(array('changed' => REQUEST_TIME))->execute();
  // TODO: the rest, such as term deletion.
}

/**
 * Implement hook_comment_*().
 *
 * Mark nodes as needing re-indexing if comments are added or changed.
 * Like search_comment().
 */

/**
 * Implements hook_comment_insert().
 */
function apachesolr_comment_insert($comment) {
  apachesolr_mark_node($comment->nid);
}

/**
 * Implements hook_comment_update().
 */
function apachesolr_comment_update($comment) {
  apachesolr_mark_node($comment->nid);
}

/**
 * Implements hook_comment_delete()
 */
function apachesolr_comment_delete($comment) {
  apachesolr_mark_node($comment->nid);
}

/**
 * Implements hook_comment_publish()
 */
function apachesolr_comment_publish($comment) {
  apachesolr_mark_node($comment->nid);
}

/**
 * Implements hook_comment_unpublish()
 */
function apachesolr_comment_unpublish($comment) {
  apachesolr_mark_node($comment->nid);
}

/**
 * Mark one node as needing re-indexing.
 */
function apachesolr_mark_node($nid) {
  db_update('apachesolr_search_node')->condition('nid', $nid)->fields(array('changed' => REQUEST_TIME))->execute();
}

/**
 * Implements of hook_node_type_update().
 */
function apachesolr_node_type_update($info) {
  if (!empty($info->old_type) && $info->old_type != $info->type) {
    // We cannot be sure we are going before or after node module.
    $nid = db_select('node')->fields('node', array('nid'))->where("type = :new OR type = :old", array(':new' => $info->type, ':old' => $info->old_type));
    db_update('apachesolr_search_node')->condition('nid', $nid, 'IN')->fields(array('changed' => REQUEST_TIME))->execute();
  }
}

/**
 * Helper function for modules implmenting hook_search's 'status' op.
 */
function apachesolr_index_status($namespace) {
  $excluded_types = apachesolr_get_excluded_types($namespace);
  list($last_change, $last_nid) = apachesolr_get_last_change($namespace);

  $query = db_select('apachesolr_search_node', 'asn')->condition('asn.status', 1);
  apachesolr_query_add_excluded_types($query, $excluded_types);
  $total = $query->countQuery()->execute()->fetchField();

  $query = db_select('apachesolr_search_node', 'asn')
    ->condition('asn.status', 1)
    ->condition(db_or()->condition('asn.changed', $last_change, '>')->condition(db_and()->condition('asn.changed', $last_change)->condition('asn.nid', $last_nid, '>')));
  apachesolr_query_add_excluded_types($query, $excluded_types);
  $remaining = $query->countQuery()->execute()->fetchField();

  return array('remaining' => $remaining, 'total' => $total);
}

/**
 * Returns last_changed and last_nid for an indexing namespace.
 */
function apachesolr_get_last_index($namespace) {
  $stored = variable_get('apachesolr_index_last', array());
  return isset($stored[$namespace]) ? $stored[$namespace] : array('last_change' => 0, 'last_nid' => 0);
}

/**
 * Clear a specific namespace's last changed and nid, or clear all.
 */
function apachesolr_clear_last_index($namespace = '') {
  if ($namespace) {
    $stored = variable_get('apachesolr_index_last', array());
    unset($stored[$namespace]);
    variable_set('apachesolr_index_last', $stored);
  }
  else {
    variable_del('apachesolr_index_last');
  }
}

/**
 * Truncate and rebuild the apachesolr_search_node table, reset the apachesolr_index_last variable.
 * This is the most complete way to force reindexing, or to build the indexing table for the
 * first time.
 *
 * @param $type
 *   A single content type to be reindexed, leaving the others unaltered.
 */
function apachesolr_rebuild_index_table($type = NULL) {
  if (isset($type)) {
    $sel_query = db_select('node')
      ->fields('node', array('nid'))
      ->condition('type', $type);
    db_delete('apachesolr_search_node')->condition('nid', $sel_query, 'IN')->execute();

    // Populate table
    $sel_query = db_select('node')
      ->fields('node', array('nid', 'status'))
      ->condition('type', $type);
    $sel_query->addExpression(REQUEST_TIME, 'changed');

    db_insert('apachesolr_search_node')->fields(array('nid', 'status', 'changed'))
      ->from($sel_query)
      ->execute();
  }
  else {
    db_delete('apachesolr_search_node')->execute();
    // Populate table
    $sel_query = db_select('node', 'n')
      ->fields('n', array('nid', 'status'));

    $insert_fields = array('nid', 'status', 'changed');
    // Check if the module is enabled, if so use the timestamp from the latest comment
    if (module_exists('comment')) {
      $sel_query->leftJoin('node_comment_statistics', 'c', 'n.nid = c.nid');
      $sel_query->addExpression('GREATEST(n.created, n.changed, COALESCE(c.last_comment_timestamp, 0))', 'changed');
    }
    else {
      $sel_query->addExpression('GREATEST(n.created, n.changed)', 'changed');
    }

    db_insert('apachesolr_search_node')->fields($insert_fields)
      ->from($sel_query)
      ->execute();

    // Make sure no nodes end up with a timestamp that's in the future.
    db_update('apachesolr_search_node')->condition('changed', REQUEST_TIME, '>')->fields(array('changed' => REQUEST_TIME))->execute();
    apachesolr_clear_last_index();
  }
  cache_clear_all('*', 'cache_apachesolr', TRUE);
}

function apachesolr_get_excluded_types($namespace) {
  $excluded_types = module_invoke_all('apachesolr_types_exclude', $namespace);
  if ($excluded_types) {
    $excluded_types = array_unique($excluded_types);
  }
  return $excluded_types;
}

function apachesolr_query_add_excluded_types($query, $excluded_types) {
  if ($excluded_types) {
    $query->innerJoin('node', 'n', 'n.nid = asn.nid');
    $query->condition('n.type', $excluded_types, 'NOT IN');
  }
}

function apachesolr_get_last_change($namespace) {
  extract(apachesolr_get_last_index($namespace));
  return array($last_change, $last_nid);
}

/**
 * Returns an array of rows from a query based on an indexing namespace.
 */
function apachesolr_get_nodes_to_index($namespace, $limit) {
  $rows = array();
  if (apachesolr_environment_variable_get(apachesolr_default_environment(), 'apachesolr_read_only', APACHESOLR_READ_WRITE) == APACHESOLR_READ_ONLY) {
    return $rows;
  }

  $excluded_types = apachesolr_get_excluded_types($namespace);
  list($last_change, $last_nid) = apachesolr_get_last_change($namespace);
  //TODO: remove old code
  //list($excluded_types, $args, $join_sql, $exclude_sql) = apachesolr_exclude_types($namespace);
  //$result = db_query_range("SELECT asn.nid, asn.changed FROM {apachesolr_search_node} asn ". $join_sql ."WHERE (asn.changed > :last_changed OR (asn.changed = :last_changed AND asn.nid > :last_nid)) AND asn.status = 1 ". $exclude_sql ."ORDER BY asn.changed ASC, asn.nid ASC", 0, $limit, $args);
  $query = db_select('apachesolr_search_node', 'asn')
    ->fields('asn', array('nid', 'changed'))
    ->condition('asn.status', 1)
    ->condition(db_or()->condition('asn.changed', $last_change, '>')->condition(db_and()->condition('asn.changed', $last_change)->condition('asn.nid', $last_nid, '>')))
    ->orderBy('asn.changed', 'ASC')
    ->orderBy('asn.nid', 'ASC')
    ->range(0, $limit);
  apachesolr_query_add_excluded_types($query, $excluded_types);
  $result = $query->execute();
  return $result;
}

/**
 * Function to handle the indexing of nodes.
 *
 * The calling function must supply a namespace.
 * Returns FALSE if no nodes were indexed (none found or error).
 */
/**
 * Handles the indexing of nodes.
 *
 * @param array $rows
 *   Each $row in $rows must have:
 *   $row->nid
 *   $row->changed
 * @param string $namespace
 *   Usually the calling module. Is used as a clue for other modules
 *   when they decide whether to create extra $documents, and is used
 *   to track the last_index timestamp.
 * @return timestamp $position
 *   Either a timestamp representing the last value of apachesolr_get_last_index
 *   to be indexed, or FALSE if indexing failed.
 */
function apachesolr_index_nodes($rows, $namespace) {
  if (!$rows) {
    // Nothing to do.
    return FALSE;
  }

  try {
    // Get the $solr object
    $solr = apachesolr_get_solr();
    // If there is no server available, don't continue.
    if (!$solr->ping(variable_get('apachesolr_ping_timeout', 4))) {
      throw new Exception(t('No Solr instance available during indexing.'));
    }
  }
  catch (Exception $e) {
    watchdog('Apache Solr', nl2br(check_plain($e->getMessage())), NULL, WATCHDOG_ERROR);
    return FALSE;
  }
  module_load_include('inc', 'apachesolr', 'apachesolr.index');
  $documents = array();
  $old_position = apachesolr_get_last_index($namespace);
  $position = $old_position;
  $position['nodes_processed'] = 0;

  // Invoke hook_apachesolr_document_handlers to find out what modules build $documents
  // from nodes in this namespace.
  $callbacks = module_invoke_all('apachesolr_document_handlers', 'node', $namespace);
  $callbacks = array_filter($callbacks, 'is_callable');

  // Always build the content for the index as an anonynmous user.
  global $user;
  drupal_save_session(FALSE);
  $saved_user = $user;
  $user = drupal_anonymous_user();

  foreach ($rows as $row) {
    try {
      // Build node. Set reset = TRUE to avoid static caching of all nodes that get indexed.
      if ($node = node_load($row->nid, NULL, TRUE)) {
        foreach ($callbacks as $callback) {
          // The callback can either return a $document or an array of $documents.
          $documents[] = $callback($node, $namespace);
        }
      }
      // Variables to track the last item changed.
      $position['last_change'] = $row->changed;
      $position['last_nid'] = $row->nid;
    }
    catch (Exception $e) {
      // Something bad happened - log the error.
      watchdog('Apache Solr', 'Error constructing documents to index: <br /> !message', array('!message' => "Node ID: {$row->nid}<br />" . nl2br(strip_tags($e->getMessage()))), WATCHDOG_ERROR);
    }
    $position['nodes_processed']++;
  }
  // Restore the user.
  $user = $saved_user;
  drupal_save_session(TRUE);

  // Flatten $documents
  $tmp = array();
  apachesolr_flatten_documents_array($documents, $tmp);
  $documents = $tmp;

  if (count($documents)) {
    try {
      watchdog('Apache Solr', 'Adding @count documents.', array('@count' => count($documents)));
      // Chunk the adds by 20s
      $docs_chunk = array_chunk($documents, 20);
      foreach ($docs_chunk as $docs) {
        $solr->addDocuments($docs);
      }
      // Set the timestamp to indicate an index update.
      apachesolr_index_set_last_updated(REQUEST_TIME);
    }
    catch (Exception $e) {
      $nids = array();
      if (!empty($docs)) {
        foreach ($docs as $doc) {
          $nids[] = $doc->entity_id;
        }
      }
      watchdog('Apache Solr', 'Indexing failed on one of the following nodes: @nids <br /> !message', array(
        '@nids' => implode(', ', $nids),
        '!message' => nl2br(strip_tags($e->getMessage())),
      ), WATCHDOG_ERROR);
      return FALSE;
    }
  }

  // Save the new position in case it changed.
  if ($namespace && $position != $old_position) {
    $stored = variable_get('apachesolr_index_last', array());
    $stored[$namespace] = $position;
    variable_set('apachesolr_index_last', $stored);
  }

  return $position;
}

/**
 * Convert date from timestamp into ISO 8601 format.
 * http://lucene.apache.org/solr/api/org/apache/solr/schema/DateField.html
 */
function apachesolr_date_iso($date_timestamp) {
  return gmdate('Y-m-d\TH:i:s\Z', $date_timestamp);
}

/**
 * Function to flatten documents array recursively.
 *
 * @param array $documents
 *   The array of documents being indexed.
 * @param array &$tmp
 *   A container variable that will contain the flattened array.
 */
function apachesolr_flatten_documents_array($documents, &$tmp) {
  foreach ($documents AS $index => $item) {
    if (is_array($item)) {
      apachesolr_flatten_documents_array($item, $tmp);
    }
    elseif (is_object($item)) {
      $tmp[] = $item;
    }
  }
}

function apachesolr_delete_node_from_index($node) {
  static $failed = FALSE;
  if ($failed) {
    return FALSE;
  }
  try {
    $solr = apachesolr_get_solr();
    $solr->deleteById(apachesolr_document_id($node->nid));
    apachesolr_index_set_last_updated(REQUEST_TIME);
    return TRUE;
  }
  catch (Exception $e) {
    watchdog('Apache Solr', nl2br(check_plain($e->getMessage())), NULL, WATCHDOG_ERROR);
    // Don't keep trying queries if they are failing.
    $failed = TRUE;
    return FALSE;
  }
}

/**
 * Set the timestamp of the last index update
 * @param $updated
 *   A timestamp or zero. If zero, the variable is deleted.
 */
function apachesolr_index_set_last_updated($updated = 0) {
  if ($updated) {
    variable_set('apachesolr_index_updated', (int) $updated);
  }
  else {
    variable_del('apachesolr_index_updated');
  }
}

/**
 * Get the timestamp of the last index update.
 * @return integer (timestamp)
 */
function apachesolr_index_get_last_updated() {
  return variable_get('apachesolr_index_updated', 0);
}

/**
 * Implements hook_cron().
 */
function apachesolr_cron() {
  // Mass update and delete functions are in the include file.
  module_load_include('inc', 'apachesolr', 'apachesolr.index');
  apachesolr_cron_check_node_table();
  try {
    $solr = apachesolr_get_solr();

    // Check for unpublished content that wasn't deleted from the index.
    $query = db_select('apachesolr_search_node', 'asn');
    $n_alias = $query->innerJoin('node', 'n', 'n.nid = asn.nid');
    $query->fields($n_alias, array('nid', 'status'));
    $query->where("asn.status <> $n_alias.status");
    $result = $query->execute();
    foreach ($result as $node) {
      apachesolr_node_update($node, FALSE);
    }

    // Check for deleted content that wasn't deleted from the index.
    $query = db_select('apachesolr_search_node', 'asn');
    $query->fields('asn', array('nid'));
    $n_alias = $query->leftJoin('node', 'n', 'n.nid = asn.nid');
    $query->isNull("$n_alias.nid");
    $result = $query->execute();
    foreach ($result as $node) {
      apachesolr_node_delete($node, FALSE);
    }

    // Optimize the index (by default once a day).
    $optimize_interval = variable_get('apachesolr_optimize_interval', 60 * 60 * 24);
    $last = variable_get('apachesolr_last_optimize', 0);
    $time = REQUEST_TIME;
    if ($optimize_interval && ($time - $last > $optimize_interval)) {
      $solr->optimize(FALSE, FALSE);
      variable_set('apachesolr_last_optimize', $time);
      apachesolr_index_set_last_updated($time);
    }

    // Only clear the cache if the index changed.
    // TODO: clear on some schedule if running multi-site.
    $updated = apachesolr_index_get_last_updated();
    if ($updated) {
      $solr->clearCache();
      // Re-populate the luke cache.
      $solr->getLuke();
      // TODO: an admin interface for setting this.  Assume for now 5 minutes.
      if ($time - $updated >= variable_get('apachesolr_cache_delay', 300)) {
        // Clear the updated flag.
        apachesolr_index_set_last_updated(0);
      }
    }
  }
  catch (Exception $e) {
    watchdog('Apache Solr', nl2br(check_plain($e->getMessage())) . ' in apachesolr_cron', NULL, WATCHDOG_ERROR);
  }
}

/**
 * Implements hook_flush_caches().
 */
function apachesolr_flush_caches() {
  return array('cache_apachesolr');
}

/**
 * A wrapper for cache_clear_all to be used as a submit handler on forms that
 * require clearing Luke cache etc.
 */
function apachesolr_clear_cache($env_id) {
  // Reset $env_id to NULL if call originates form a form submit handler.
  if (is_array($env_id)) {
    $env_id = NULL;
  }
  try {
    $solr = apachesolr_get_solr($env_id);
    $solr->clearCache();
  }
  catch (Exception $e) {
    watchdog('Apache Solr', nl2br(check_plain($e->getMessage())), NULL, WATCHDOG_ERROR);
    drupal_set_message(nl2br(check_plain($e->getMessage())), 'warning');
  }
}

/**
 * Implements hook_node_insert().
 */
function apachesolr_node_insert($node) {
  // Make sure no node ends up with a timestamp that's in the future by using
  // REQUEST_TIME rather than the node's changed or created timestamp.
  db_insert('apachesolr_search_node')->fields(array('nid' => $node->nid, 'status' => $node->status, 'changed' => REQUEST_TIME))->execute();
}

/**
 * Implements hook_node_delete().
 */
function apachesolr_node_delete($node, $set_message = TRUE) {
  if (apachesolr_delete_node_from_index($node)) {
    // There was no exception, so delete from the table.
    db_delete('apachesolr_search_node')->condition('nid', $node->nid)->execute();
    if ($set_message && user_access('administer search') && variable_get('apachesolr_set_nodeapi_messages', 1)) {
      apachesolr_set_stats_message('Deleted content will be removed from the Apache Solr search index in approximately @autocommit_time.');
    }
  }
}

/**
 * Implements hook_node_update().
 */
function apachesolr_node_update($node, $set_message = TRUE) {
  // Check if the node has gone from published to unpublished.
  if (!$node->status && db_select('apachesolr_search_node', 'asn')->fields('asn', array('status'))->condition('nid', $node->nid)->execute()) {
    if (apachesolr_delete_node_from_index($node)) {
      // There was no exception, so update the table.
      db_update('apachesolr_search_node')->condition('nid', $node->nid)->fields(array('changed' => REQUEST_TIME, 'status' => $node->status))->execute();
      if ($set_message && user_access('administer search') && variable_get('apachesolr_set_nodeapi_messages', 1)) {
        apachesolr_set_stats_message('Unpublished content will be removed from the Apache Solr search index in approximately @autocommit_time.');
      }
    }
  }
  else {
    db_update('apachesolr_search_node')->condition('nid', $node->nid)->fields(array('changed' => REQUEST_TIME, 'status' => $node->status))->execute();
  }
}

/**
 * Call drupal_set_message() with the text.
 *
 * The text is translated with t() and substituted using Solr stats.
 */
function apachesolr_set_stats_message($text, $type = 'status', $repeat = FALSE) {
  try {
    $solr = apachesolr_get_solr();
    $stats_summary = $solr->getStatsSummary();
    drupal_set_message(t($text, $stats_summary), $type, FALSE);
  }
  catch (Exception $e) {
    watchdog('Apache Solr', nl2br(check_plain($e->getMessage())), NULL, WATCHDOG_ERROR);
  }
}

/**
 * Implements hook_block_info().
 */
function apachesolr_block_info() {
  // Get all of the moreLikeThis blocks that the user has created
  $blocks = apachesolr_mlt_list_blocks();
  // Add the sort block.
  $blocks['sort'] = array(
    'info' => t('Apache Solr Core: Sorting'),
    'cache' => DRUPAL_CACHE_PER_PAGE,
  );
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function apachesolr_block_view($delta = '') {
  if ($delta != 'sort' && ($node = menu_get_object()) && (!arg(2) || arg(2) == 'view')) {
    $suggestions = array();
    // Determine whether the user can view the current node. Probably not necessary.
    $block = apachesolr_mlt_load_block($delta);
    if ($block && node_access('view', $node)) {
      $docs = apachesolr_mlt_suggestions($block, apachesolr_document_id($node->nid));
      if (!empty($docs)) {
        $suggestions['subject'] = check_plain($block['name']);
        $suggestions['content'] = theme('apachesolr_mlt_recommendation_block', array('docs' => $docs, 'delta' => $delta));
      }
    }
    return $suggestions;
  }
  elseif (apachesolr_has_searched() && !apachesolr_suppress_blocks() && $delta == 'sort') {

    $response = NULL;
    $query = apachesolr_current_query();
    if ($query) {
      // Get the query and response. Without these no blocks make sense.
      $response = apachesolr_static_response_cache($query->getSearcher());
    }
    if (empty($response) || ($response->response->numFound < 2)) {
      return;
    }

    $sorts = $query->getAvailableSorts();

    // Get the current sort as an array.
    $solrsort = $query->getSolrsort();

    $sort_links = array();
    $path = $query->getPath();
    $new_query = clone $query;
    $toggle = array('asc' => 'desc', 'desc' => 'asc');
    foreach ($sorts as $name => $sort) {
      $active = $solrsort['#name'] == $name;
      if ($name == 'score') {
        $direction = '';
        $new_direction = 'desc'; // We only sort by descending score.
      }
      elseif ($active) {
        $direction = $toggle[$solrsort['#direction']];
        $new_direction = $toggle[$solrsort['#direction']];
      }
      else {
        $direction = '';
        $new_direction = $sort['default'];
      }
      $new_query->setSolrsort($name, $new_direction);
      $sort_links[$name] = array(
        'text' => $sort['title'],
        'path' => $path,
        'options' => array('query' => $new_query->getSolrsortUrlQuery()),
        'active' => $active,
        'direction' => $direction,
      );
    }
    // Allow other modules to add or remove sorts.
    drupal_alter('apachesolr_sort_links', $sort_links);
    foreach ($sort_links as $name => $link) {
      $themed_links[$name] = theme('apachesolr_sort_link', $link);
    }
    return array(
    'subject' => t('Sort by'),
      'content' => theme('apachesolr_sort_list', array('items' => $themed_links))
  );
  }
}

/**
 * Implements hook_block_configure().
 */
function apachesolr_block_configure($delta = '') {
  if ($delta != 'sort') {
    require_once(drupal_get_path('module', 'apachesolr') . '/apachesolr.admin.inc');
    return apachesolr_mlt_block_form($delta);
  }
}

/**
 * Implements hook_block_save().
 */
function apachesolr_block_save($delta = '', $edit = array()) {
  if ($delta != 'sort') {
    require_once(drupal_get_path('module', 'apachesolr') . '/apachesolr.admin.inc');
    apachesolr_mlt_save_block($edit, $delta);
  }
}

/**
 * Implements hook_form_[form_id]_alter().
 *
 * Make sure to flush cache when content types are changed.
 */
function apachesolr_form_node_type_form_alter(&$form, $form_state) {
  $form['#submit'][] = 'apachesolr_clear_cache';
}

/**
 * Implements hook_form_[form_id]_alter(). (D7)
 *
 * Make sure to flush cache when fields are added.
 */
function apachesolr_form_field_ui_field_overview_form_alter(&$form, $form_state) {
  $form['#submit'][] = 'apachesolr_clear_cache';
}

/**
 * Implements hook_form_[form_id]_alter(). (D7)
 *
 * Make sure to flush cache when fields are updated.
 */
function apachesolr_form_field_ui_field_edit_form_alter(&$form, $form_state) {
  $form['#submit'][] = 'apachesolr_clear_cache';
}

/**
 * Sets breadcrumb trails for Facet API settings forms.
 *
 * @param FacetapiAdapter $adapter
 *   The Facet API adapter object.
 * @param array $realm
 *   The realm definition.
 */
function apachesolr_set_facetapi_breadcrumb(FacetapiAdapter $adapter, array $realm) {
  if ('apachesolr' == $adapter->getId()) {
    // Hack here that depnds on our construction of the searcher name in this way.
    list(, $env_id) = explode('@', $adapter->getSearcher());
    // Appends additional breadcrumb items.
    $breadcrumb = drupal_get_breadcrumb();
    $breadcrumb[] = l(t('Apache Solr search environment edit'), 'admin/config/search/apachesolr-env/' . $env_id);
    $breadcrumb[] = l($realm['label'], 'admin/config/search/apachesolr-env/' . $env_id . '/facets/' . $realm['name']);
    drupal_set_breadcrumb($breadcrumb);
  }
}

/**
 * Implements hook_form_[form_id]_alter(). (D7)
 */
function apachesolr_form_facetapi_facet_settings_form_alter(&$form, $form_state) {
  apachesolr_set_facetapi_breadcrumb($form['#facetapi']['adapter'], $form['#facetapi']['realm']);
}

/**
 * Implements hook_form_[form_id]_alter(). (D7)
 */
function apachesolr_form_facetapi_facet_dependencies_form_alter(&$form, $form_state) {
  apachesolr_set_facetapi_breadcrumb($form['#facetapi']['adapter'], $form['#facetapi']['realm']);
}

/**
 * Semaphore that indicates whether a search has been done. Blocks use this
 * later to decide whether they should load or not.
 *
 * @param $searched
 *   A boolean indicating whether a search has been executed.
 *
 * @return
 *   TRUE if a search has been executed.
 *   FALSE otherwise.
 */
function apachesolr_has_searched($searched = NULL) {
  static $_searched = FALSE;
  if (is_bool($searched)) {
    $_searched = $searched;
  }
  return $_searched;
}

/**
 * Semaphore that indicates whether Blocks should be suppressed regardless
 * of whether a search has run.
 *
 * @param $flag
 *   A boolean indicating whether to suppress.
 *
 * @return
 *   TRUE if a search has been executed.
 *   FALSE otherwise.
 */
function apachesolr_suppress_blocks($flag = NULL) {
  static $_flag = FALSE;
  if (is_bool($flag)) {
    $_flag = $flag;
  }
  return $_flag;
}

/**
 * Get or set the default environment ID for the current page.
 */
function apachesolr_default_environment($env_id = NULL) {
  static $default_env_id = NULL;

  if (isset($env_id)) {
    $default_env_id = $env_id;
  }
  if (empty($default_env_id)) {
    $default_env_id = variable_get('apachesolr_default_environment', 'solr');
  }
  return $default_env_id;
}

/**
 * Factory method for solr singleton objects. Structure allows for an arbitrary
 * number of solr objects to be used based on a name whie maps to
 * the host, port, path combination.
 * Get an instance like this:
 *   $solr = apachesolr_get_solr();
 *
 * @throws Exception
 */
function apachesolr_get_solr($id = NULL) {
  $solr_cache = &drupal_static(__FUNCTION__);

  $environments = apachesolr_load_all_environments();

  if (empty($id) || empty($environments[$id])) {
    $id = apachesolr_default_environment();
  }

  $class = $environments[$id]['service_class'];

  if (empty($solr_cache[$id])) {
    // Use the default class if none is specified.
    if (empty($class)) {
      $class = variable_get('apachesolr_service_class', 'DrupalApacheSolrService');
    }
    // Takes advantage of auto-loading.
    $solr = new $class($environments[$id]['url'], $id);
    $solr_cache[$id] = $solr;
  }
  return $solr_cache[$id];
}

function apachesolr_load_all_environments() {
  $environments = &drupal_static(__FUNCTION__);

  if (isset($environments)) {
    return $environments;
  }
  // Use cache_get to avoid DB when using memcache, etc.
  $cache = cache_get('apachesolr:environments', 'cache_apachesolr');
  if (isset($cache->data)) {
    $environments = $cache->data;
  }
  else {
    $environments = db_query('SELECT * FROM {apachesolr_environment}')->fetchAllAssoc('env_id', PDO::FETCH_ASSOC);
    foreach ($environments as $id => &$environment) {
      $conf = db_query('SELECT name, value FROM {apachesolr_environment_variable} WHERE env_id = :env_id', array('env_id' => $id))->fetchAllAssoc('name', PDO::FETCH_ASSOC);
      foreach ($conf as $name => $data) {
        $environment['conf'][$name] = unserialize($data['value']);
      }
    }
    cache_set('apachesolr:environments', $environments, 'cache_apachesolr');
  }
  return $environments;
}

function apachesolr_environment_load($env_id) {
  $environments = apachesolr_load_all_environments();
  return isset($environments[$env_id]) ? $environments[$env_id] : FALSE;
}

function apachesolr_environment_delete($env_id) {
  $environment = apachesolr_environment_load($env_id);
  if ($environment) {
    db_delete('apachesolr_environment')
      ->condition('env_id', $env_id)
      ->execute();
    db_delete('apachesolr_environment_variable')
      ->condition('env_id', $env_id)
      ->execute();

    module_invoke_all('apachesolr_environment_delete', $environment);

    cache_clear_all('apachesolr:environments', 'cache_apachesolr');
    drupal_static_reset('apachesolr_load_all_environments');
    drupal_static_reset('apachesolr_get_solr');
  }
}

function apachesolr_environment_save($environment) {
  $default = array('env_id' => NULL, 'name' => '', 'url' => '', 'service_class' => '');
  $is_new = !apachesolr_environment_load($environment['env_id']);
  $conf = isset($environment['conf']) ? $environment['conf'] : array();
  // Remove any unexpected fields.
  // @todo - getthis from the schema?.
  $environment = array_intersect_key($environment, $default);
  if ($is_new) {
    db_insert('apachesolr_environment')
      ->fields($environment)
      ->execute();
  }
  else {
    db_update('apachesolr_environment')
      ->fields($environment)
      ->condition('env_id', $environment['env_id'])
      ->execute();
  }
  // Update the environment variables (if any).
  foreach ($conf as $name => $value) {
    db_merge('apachesolr_environment_variable')
      ->key(array('env_id' => $environment['env_id'], 'name' => $name))
      ->fields(array('value' => serialize($value)))
      ->execute();
  }
  cache_clear_all('apachesolr:environments', 'cache_apachesolr');
  drupal_static_reset('apachesolr_load_all_environments');
  drupal_static_reset('apachesolr_get_solr');
}

/**
 * Get a named variable, or return the default.
 *
 * @see variable_get()
 */
function apachesolr_environment_variable_get($env_id, $name, $default = NULL) {
  $environment = apachesolr_environment_load($env_id);
  if (isset($environment['conf'][$name])) {
    return $environment['conf'][$name];
  }
  return $default;
}

/**
 * Set a named variable, or return the default.
 *
 * @see variable_set()
 */
function apachesolr_environment_variable_set($env_id, $name, $value) {
  db_merge('apachesolr_environment_variable')
    ->key(array('env_id' => $env_id, 'name' => $name))
    ->fields(array('value' => serialize($value)))
    ->execute();
  cache_clear_all('apachesolr:environments', 'cache_apachesolr');
  drupal_static_reset('apachesolr_load_all_environments');
  drupal_static_reset('apachesolr_get_solr');
}

/**
 * Get a named variable, or return the default.
 *
 * @see variable_del()
 */
function apachesolr_environment_variable_del($env_id, $name) {
  db_delete('apachesolr_environment_variable')
    ->condition('env_id', $env_id)
    ->condition('name', $name)
    ->execute();
  cache_clear_all('apachesolr:environments', 'cache_apachesolr');
  drupal_static_reset('apachesolr_load_all_environments');
  drupal_static_reset('apachesolr_get_solr');
}

/**
 * Checks if a specific Apache Solr server is available.
 *
 * @return boolean TRUE if the server can be pinged, FALSE otherwise.
 */
function apachesolr_server_status($url, $class = NULL) {
  if (empty($class)) {
    $class = variable_get('apachesolr_service_class', 'DrupalApacheSolrService');
  }
  $ping = FALSE;
  try {
    // Takes advantage of auto-loading.
    $solr = new $class($url);
    $ping = @$solr->ping(variable_get('apachesolr_ping_timeout', 4));
  }
  catch (Exception $e) {
    watchdog('Apache Solr', nl2br(check_plain($e->getMessage())), NULL, WATCHDOG_ERROR);
  }
  return $ping;
}

/**
 * Execute a keyword search based on a query object.
 *
 * Normally this function is used with the default (dismax) handler for keyword
 * searches. The $final_query that's returned will have been modified by
 * both hook_apachesolr_query_prepare() and hook_apachesolr_query_alter().
 *
 * @param $current_query
 *   A query object from apachesolr_drupal_query().  It will be modified by
 *   hook_apachesolr_prepare_query() and then cached in apachesolr_current_query().
 * @param $page
 *   For paging into results, using $current_query->params['rows'] results per page.
 *
 * @return array($final_query, $response)
 *
 * @throws Exception
 */
function apachesolr_do_query(DrupalSolrQueryInterface $current_query, $page = 0) {
  if (!is_object($current_query)) {
    throw new Exception(t('NULL query object in function apachesolr_do_query()'));
  }
  // Allow modules to alter the query prior to statically caching it.
  // This can e.g. be used to add available sorts.
  $searcher = $current_query->getSearcher();

  if (module_exists('facetapi')) {
    // Gets enabled facets, adds filter queries to $params.
    $adapter = facetapi_adapter_load($searcher);
    if ($adapter) {
      $adapter->addActiveFilters($current_query);
    }
  }

  foreach (module_implements('apachesolr_query_prepare') as $module) {
    $function_name = $module . '_apachesolr_query_prepare';
    $function_name($current_query);
  }

  // Cache the original query. Since all the built queries go through
  // this process, all the hook_invocations will happen later
  $query = apachesolr_current_query($current_query);

  // This hook allows modules to modify the query and params objects.
  drupal_alter('apachesolr_query', $query);

  if ($query->abort_search) {
    // A module implementing HOOK_apachesolr_query_alter() aborted the search.
    return array(NULL, array());
  }
  $query->addParam('start', $page * $query->getParam('rows'));

  $keys = $query->getParam('q');

  if (strlen($keys) == 0 && ($filters = $query->getFilters())) {
    // Move the fq params to q.alt for better performance. Only suitable
    // when using dismax or edismax, so we keep this out of the query class itself
    // for now.
    $qalt = array();
    foreach ($filters as $delta => $filter) {
      // Move the fq param if it has no local params and is not negative.
      if (!$filter['#exclude'] && !$filter['#local']) {
        $qalt[] = '(' . $query->makeFilterQuery($filter) . ')';
        $query->removeFilter($filter['#name'], $filter['#value'], $filter['#exclude']);
      }
    }
    if ($qalt) {
      $query->addParam('q.alt', implode(' ', $qalt));
    }
  }
  // We must run htmlspecialchars() here since converted entities are in the index.
  // and thus bare entities &, > or < won't match. Single quotes are converted
  // too, but not double quotes since the dismax parser looks at them for
  // phrase queries.
  $keys = htmlspecialchars($keys, ENT_NOQUOTES, 'UTF-8');
  $keys = str_replace("'", '&#039;', $keys);
  $response = $query->search($keys);
  // The response is cached so that it is accessible to the blocks and anything
  // else that needs it beyond the initial search.
  apachesolr_static_response_cache($searcher, $response);
  return array($query, $response);
}

/**
 * It is important to hold on to the Solr response object for the duration of the
 * page request so that we can use it for things like building facet blocks.
 *
 * @param $searcher
 *   Name of the searcher - e.g. from $query->getSearcher().
 */
function apachesolr_static_response_cache($searcher, $response = NULL) {
  static $_response = array();

  if (is_object($response)) {
    $_response[$searcher] = clone $response;
  }
  if (!isset($_response[$searcher])) {
    $_response[$searcher] = NULL;
  }
  return $_response[$searcher];
}

/**
 * Factory function for query objects.
 *
 * @param $name
 *   The search name, used for finding the correct blocks and other config.
 *   Typically "apachesolr".
 * @param $params
 *   Array of params , such as 'q', 'fq' to be applied.
 * @param $solrsort
 *   Visible string telling solr how to sort.
 * @param $base_path
 *   The search base path (without the keywords) for this query.
 * @param $solr
 *   An instance of DrupalApacheSolrService.
 *
 * @return
 *   DrupalSolrQueryInterface object.
 *
 * @throws Exception
 */
function apachesolr_drupal_query($name, $params = array(), $solrsort = '', $base_path = '', $solr = NULL) {
  $class = variable_get('apachesolr_query_class', 'SolrBaseQuery');

  if (empty($solr)) {
    $solr = apachesolr_get_solr();
  }
  return new $class($name, $solr, $params, $solrsort, $base_path);
}

/**
 * Static getter/setter for the current query. Only set once per page.
 */
function apachesolr_current_query(DrupalSolrQueryInterface $query = NULL) {
  static $saved_query = NULL;

  if (is_object($query)) {
    $saved_query = clone $query;
  }

  return is_object($saved_query) ? clone $saved_query : NULL;
}

/**
 * Construct a dynamic index name based on information about a field.
 *
 * array('index_type' => 'integer',
 *        'multiple' => TRUE,
 *        'name' => 'fieldname',
 *        ),
 */
function apachesolr_index_key($field) {
  switch ($field['index_type']) {
    case 'text':
      $type_prefix = 't';
      break;
    case 'text-omitNorms':
      $type_prefix = 'to';
      break;
    case 'text-edgeNgram':
      $type_prefix = 'te';
      break;
    case 'text-whiteSpace':
      $type_prefix = 'tw';
      break;
    case 'integer':
      $type_prefix = 'i'; // long integer
      break;
    case 'half-int':
      $type_prefix = 'h'; // 32 bit integer
      break;
    case 'float':
      $type_prefix = 'f'; // float; sortable.
      break;
    case 'double':
      $type_prefix = 'p'; // double; sortable d was used for date.
      break;
      case 'sint':
      $type_prefix = 'is'; // long integer sortable (deprecated)
      break;
    case 'boolean':
      $type_prefix = 'b';
      break;
    case 'date':
      $type_prefix = 'd'; // date trie
      break;
    case 'tint':
      $type_prefix = 'it'; // long integer trie; sortable, best for range queries
      break;
    case 'thalf-int':
      $type_prefix = 'ht'; // 32 bit integer trie (sortable)
      break;
    case 'tfloat':
      $type_prefix = 'ft'; // float trie; sortable, best for range queries.
      break;
    case 'tdouble':
      $type_prefix = 'pt'; // double trie; d was used for date.
      break;
    case 'sfloat':
      $type_prefix = 'fs'; // float, sortable (use for sorting missing last).
      break;
    case 'sdouble':
      $type_prefix = 'ps'; // double sortable; (use for sorting missing last).
      break;
     case 'string':
    default:
      $type_prefix = 's'; // String
  }
  $sm = $field['multiple'] ? 'm_' : 's_';
  // Block deltas are limited to 32 chars.
  return substr($type_prefix . $sm . $field['name'], 0, 32);
}

/**
 * Try to map a schema field name to a human-readable description.
 */
function apachesolr_field_name_map($field_name) {
  static $map;

  if (!isset($map)) {
    $map = array(
      'content' => t('The full, rendered content (e.g. the rendered node body)'),
      'ts_comments' => t('The rendered comments associated with a node'),
      'tos_content_extra' => t('Extra rendered content or keywords'),
      'label' => t('Title or label'),
      'teaser' => t('Teaser or preview'),
      'tos_name' => t('Author name'),
      'path_alias' => t('Path alias'),
      'taxonomy_names' => t('All taxonomy term names'),
      'tags_h1' => t('Body text inside H1 tags'),
      'tags_h2_h3' => t('Body text inside H2 or H3 tags'),
      'tags_h4_h5_h6' => t('Body text inside H4, H5, or H6 tags'),
      'tags_inline' => t('Body text in inline tags like EM or STRONG'),
      'tags_a' => t('Body text inside links (A tags)'),
      'tid' => t('Taxonomy term IDs'),
    );
    if (module_exists('taxonomy')) {
      foreach (taxonomy_get_vocabularies() as $vocab) {
        $map['tm_vid_' . $vocab->vid . '_names'] = t('Taxonomy term names only from the %name vocabulary', array('%name' => $vocab->name));
        $map['im_vid_' . $vocab->vid] = t('Taxonomy term IDs from the %name vocabulary', array('%name' => $vocab->name));
      }
    }
    foreach (apachesolr_entity_fields('node') as $field_nm => $field_info) {
      $map[apachesolr_index_key($field_info)] = t('Field of type @type: %label', array('@type' => $field_info['field']['type'], '%label' => $field_info['display_name']));
    }
    drupal_alter('apachesolr_field_name_map', $map);
  }
  return isset($map[$field_name]) ? $map[$field_name] : $field_name;
}

/**
 * Validation function for the Facet API facet settings form.
 *
 * Apache Solr does not support the combination of OR facets
 * and facet missing, so catch that at validation.
 */
function apachesolr_facet_form_validate($form, &$form_state) {
  if (($form_state['values']['global']['operator'] == FACETAPI_OPERATOR_OR) && $form_state['values']['global']['facet_missing']) {
    form_set_error('operator', t('Apache Solr does not support <em>facet missing</em> in combination with the OR operator.'));
  }
}

/**
 * Returns array containing information about node fields that should be indexed
 */
function apachesolr_entity_fields($entity_type = 'node') {
  static $fields = array();
  $fields = &drupal_static(__FUNCTION__, array());

  if (!isset($fields[$entity_type])) {
    $fields[$entity_type] = array();

    $mappings = module_invoke_all('apachesolr_field_mappings');

    foreach (array_keys($mappings) as $key) {
      // Set all values with defaults.
      $mappings[$key] += array(
        'dependency plugins' => array('bundle', 'role'),
        'map callback' => FALSE,
        'hierarchy callback' => FALSE,
        'indexing_callback' => '',
        'index_type' => 'string',
        'name_callback' => '',
        'facets' => FALSE,
        'facet missing allowed' => FALSE,
        // Field API allows any field to be multi-valued.
        'multiple' => TRUE,
      );
    }

    // Allow other modules to add or alter mappings.
    drupal_alter('apachesolr_field_mappings', $mappings);
    $modules = system_get_info('module');
    $instances = field_info_instances($entity_type);
    foreach (field_info_fields() as $field_name => $field) {
      $row = array();
      if (isset($field['bundles'][$entity_type]) && (isset($mappings['per-field'][$field_name]) || isset($mappings[$field['type']]))) {
        // Find the mapping.
        if (isset($mappings['per-field'][$field_name])) {
          $row = $mappings['per-field'][$field_name];
        }
        else {
          $row = $mappings[$field['type']];
        }
        // The field info array.
        $row['field'] = $field;
        // Since we use the index key as the block delta in apachesolr_search, we need a name
        // to build whatever the index key is that is used for faceting.
        // @todo: for fields like taxonomy we are indexing multiple Solr fields
        // per entity field, but are keying on a single Solr field name here.
        $function = $row['name_callback'];
        if ($function && is_callable($function)) {
          $row['name'] = $function($field);
        }
        else {
          $row['name'] = $field['id'] . '_' . $field['field_name'];
        }
        $row['module_name'] = $modules[$field['module']]['name'];
        // Set display name
        $display_name = array();
        foreach ($field['bundles'][$entity_type] as $bundle) {
          if (empty($instances[$bundle][$field_name]['display']['search_index']) || $instances[$bundle][$field_name]['display']['search_index'] != 'hidden') {
            $row['display_name'] = $instances[$bundle][$field_name]['label'];
            $row['bundles'][] = $bundle;
          }
        }
        // Only add to the $fields array if some instances are displayed for the search index.
        if (!empty($row['bundles'])) {
          // Use the Solr index key as the array key.
          $fields[$entity_type][apachesolr_index_key($row)] = $row;
        }
      }
    }
  }
  return $fields[$entity_type];
}

/**
 * Strip html tags and also control characters that cause Jetty/Solr to fail.
 */
function apachesolr_clean_text($text) {
  // Add spaces before stripping tags to avoid running words together.
  $text = filter_xss(str_replace(array('<', '>'), array(' <', '> '), $text), array());
  // Decode entities and then make safe any < or > characters.
  return htmlspecialchars(html_entity_decode($text, ENT_QUOTES, 'UTF-8'), ENT_QUOTES, 'UTF-8');
}

/**
 * Use the list.module's list_allowed_values() to format the
 * field based on its value ($facet).
 *
 *  @param $facet string
 *    The indexed value
 *  @param $options
 *    An array of options including the hook_block $delta.
 */
function apachesolr_fields_list_facet_map_callback($facets, $options) {
  $map = array();
  $allowed_values = array();
  // @see list_field_formatter_view()
  $fields = field_info_fields();
  $field_name = $options['field']['field_name'];
  if (isset($fields[$field_name])) {
    $allowed_values = list_allowed_values($fields[$field_name]);
  }
  foreach ($facets as $key) {
    if (isset($allowed_values[$key])) {
      $map[$key]['#markup'] = field_filter_xss($allowed_values[$key]);
    }
    elseif ($key == '_empty_' && $options['facet missing allowed']) {
      // Facet missing.
      $map[$key]['#markup'] = theme('facetapi_facet_missing', array('field_name' => $options['display_name']));
    }
    else {
      $map[$key]['#markup'] = field_filter_xss($key);
    }
    // The value has already been filtered.
    $map[$key]['#html'] = TRUE;
  }
  return $map;
}

/**
 * Use the content.module's content_format() to format the
 * field based on its nid ($facet).
 *
 *  @param $facet string
 *    The indexed value
 *  @param $options
 *    An array of options including the hook_block $delta.
 *  @see http://drupal.org/node/1059372
 */
function apachesolr_cck_nodereference_field_callback($facet, $options) {
  if (function_exists('content_format')) {
    return strip_tags(content_format($options['delta'], array('nid' => $facet)));
  }
  else {
    return $facet;
  }
}

/**
 * Use the content.module's content_format() to format the
 * field based on its uid ($facet).
 *
 *  @param $facet string
 *    The indexed value
 *  @param $options
 *    An array of options including the hook_block $delta.
 *  @see http://drupal.org/node/1059372
 */
function apachesolr_cck_userreference_field_callback($facet, $options) {
  if (function_exists('content_format')) {
    return strip_tags(content_format($options['delta'], array('uid' => $facet)));
  }
  else {
    return $facet;
  }
}

/**
 * Returns the callback function appropriate for a given entity type/bundle.
 *
 * @param string $entity_type
 *   The entity type for which we want to know the approprite callback.
 * @param string $callback
 *   The callback for which we want the appropriate function.
 * @param string $bundle
 *   If specified, the bundle of the entity in question.  Some callbacks may
 *   be overridden on a bundle-level.  Not specified only the entity-level
 *   callback will be checked.
 * @return string
 *   The function name for this callback, or NULL if not specified.
 */
function apachesolr_entity_get_callback($entity_type, $callback, $bundle = NULL) {
  $info = entity_get_info($entity_type);

  // A bundle-specific callback takes precedence over the generic one for the
  // entity type.
  if ($bundle && isset($info['bundles'][$bundle]['apachesolr'][$callback])) {
    $callback_function = $info['bundles'][$bundle]['apachesolr'][$callback];
  }
  elseif (isset($info['apachesolr'][$callback])) {
    $callback_function = $info['apachesolr'][$callback];
  }
  else {
    $callback_function = NULL;
  }

  return $callback_function;
}

/**
 * Determines if we should index the provided entity.
 *
 * Whether or not a given entity is indexed is determined on a per-bundle basis.
 * Entities/Bundles that have no index flag are presumed to not get indexed.
 *
 * @param stdClass $entity
 *   The entity we may or may not want to index.
 * @param string $type
 *   The type of entity.
 * @return boolean
 *   TRUE if this entity should be indexed, FALSE otherwise.
 */
function apachesolr_entity_should_index($entity, $type) {
  $info = entity_get_info($type);
  list($id, $vid, $bundle) = entity_extract_ids($type, $entity);

  if ($bundle && isset($info['bundles'][$bundle]['apachesolr']['index']) && $info['bundles'][$bundle]['apachesolr']['index']) {
    return TRUE;
  }

  return FALSE;
}


/**
 * Implements hook_theme().
 */
function apachesolr_theme() {
  return array(
    /**
     * Returns a list of links generated by apachesolr_sort_link
     */
    'apachesolr_sort_list' => array(
      'variables' => array('items' => NULL),
    ),
    /**
     * Returns a link which can be used to search the results.
     */
    'apachesolr_sort_link' => array(
      'variables' => array('text' => NULL, 'path' => NULL, 'options' => NULL, 'active' => FALSE, 'direction' => ''),
    ),
    /**
     * Returns a list of results (docs) in content recommendation block
     */
    'apachesolr_mlt_recommendation_block' => array(
      'variables' => array('docs' => NULL, 'delta' => NULL),
    ),
    /**
     * Themes the title links in admin settings pages.
     */
    'apachesolr_settings_title' => array(
      'variables' => array('env_id' => NULL),
    ),
  );
}

/**
 * A per-environment version of system_settings_form().
 */
function apachesolr_settings_form($form, $env_id) {
  $form['#env_id'] = $env_id;
  $form['actions']['#type'] = 'actions';
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save configuration'),
    '#submit' => array('apachesolr_settings_form_submit'),
  );
  $form['actions']['reset'] = array(
    '#type' => 'submit',
    '#value' => t('Reset to defaults'),
    '#submit' => array('apachesolr_settings_form_reset'),
  );

  return $form;
}

function apachesolr_settings_form_submit($form, &$form_state) {
  // Exclude unnecessary elements.
  form_state_values_clean($form_state);

  foreach ($form_state['values'] as $key => $value) {
    if (is_array($value) && isset($form_state['values']['array_filter'])) {
      $value = array_keys(array_filter($value));
    }

    // There is no need to set default variable values.
    if (!isset($form[$key]['#default_value']) || is_array($value) || $form[$key]['#default_value'] != $value) {
      apachesolr_environment_variable_set($form['#env_id'], $key, $value);
    }
  }

  drupal_set_message(t('The configuration options have been saved.'));
}

function apachesolr_settings_form_reset($form, &$form_state) {
  // Exclude unnecessary elements.
  form_state_values_clean($form_state);

  foreach ($form_state['values'] as $key => $value) {
    apachesolr_environment_variable_del($form['#env_id'], $key);
  }
  drupal_set_message(t('The configuration options have been reset to their default values.'));
}

/**
 * Performs a moreLikeThis query using the settings and retrieves documents.
 *
 * @param $settings
 *   An array of settings.
 * @param $id
 *   The Solr ID of the document for which you want related content.
 *   For a node that is apachesolr_document_id($node->nid)
 *
 * @return An array of response documents, or NULL
 */
function apachesolr_mlt_suggestions($settings, $id, $solr = NULL) {

  try {
    $fields = array(
      'mlt_mintf' => 'mlt.mintf',
      'mlt_mindf' => 'mlt.mindf',
      'mlt_minwl' => 'mlt.minwl',
      'mlt_maxwl' => 'mlt.maxwl',
      'mlt_maxqt' => 'mlt.maxqt',
      'mlt_boost' => 'mlt.boost',
      'mlt_qf' => 'mlt.qf',
    );
    $params = array(
      'q' => 'id:' . $id,
      'qt' => 'mlt',
      'fl' => array('entity_id', 'entity_type', 'label', 'path', 'url'),
      'mlt.fl' => $settings['mlt_fl'],
      'start' => 0,
      'rows' => $settings['num_results'],
    );
    // We can optionally specify a Solr object.
    $query = apachesolr_drupal_query('apachesolr_mlt', $params, '', '', $solr);

    foreach ($fields as $form_key => $name) {
      if (!empty($settings[$form_key])) {
        $query->addParam($name, $settings[$form_key]);
      }
    }

    $type_filters = array();
    if (is_array($settings['mlt_type_filters']) && !empty($settings['mlt_type_filters'])) {
      $query->addFilter('bundle', '(' . implode(' OR ', $settings['mlt_type_filters']) . ') ');
    }

    if ($custom_filters = $settings['mlt_custom_filters']) {
      // @todo - fix the settings form to take a comma-delimited set of filters.
      $query->addFilter('', $custom_filters);
    }

    // This hook allows modules to modify the query object.
    drupal_alter('apachesolr_query', $query);
    if ($query->abort_search) {
      return;
    }

    $response = $query->search();

    if ($response->response) {
      $docs = (array) end($response->response);
      return $docs;
    }
  }
  catch (Exception $e) {
    watchdog('Apache Solr', nl2br(check_plain($e->getMessage())), NULL, WATCHDOG_ERROR);
  }
}

/**
 * Implements hook_form_[form_id]_alter().
 */
function apachesolr_form_block_admin_display_form_alter(&$form) {
  foreach ($form as $key => $block) {
    if ((strpos($key, "apachesolr_mlt-") === 0) && $block['module']['#value'] == 'apachesolr') {
      $form[$key]['delete'] = array('#value' => l(t('delete'), 'admin/config/search/apachesolr/mlt/delete_block/' . $block['delta']['#value']));
    }
  }
}

/**
 * Implements hook_hook_info().
 */
function apachesolr_hook_info() {
  $hooks['apachesolr_field_mappings'] = array(
    'group' => 'apachesolr',
  );
  $hooks['apachesolr_field_mappings_alter'] = array(
    'group' => 'apachesolr',
  );

  return $hooks;
}

/**
 * Implements hook_apachesolr_field_mappings().
 */
function field_apachesolr_field_mappings() {
  $mappings = array(
    'list_integer' => array(
      'indexing_callback' => 'apachesolr_fields_list_indexing_callback',
      'map callback' => 'apachesolr_fields_list_facet_map_callback',
      'index_type' => 'integer',
      'facets' => TRUE,
      'facet missing allowed' => TRUE,
    ),
    'list_float' => array(
      'indexing_callback' => 'apachesolr_fields_list_indexing_callback',
      'map callback' => 'apachesolr_fields_list_facet_map_callback',
      'index_type' => 'float',
      'facets' => TRUE,
      'facet missing allowed' => TRUE,
    ),
    'list_text' => array(
      'indexing_callback' => 'apachesolr_fields_list_indexing_callback',
      'map callback' => 'apachesolr_fields_list_facet_map_callback',
      'index_type' => 'string',
      'facets' => TRUE,
      'facet missing allowed' => TRUE,
    ),
    'list_boolean' => array(
      'indexing_callback' => 'apachesolr_fields_list_indexing_callback',
      'map callback' => 'apachesolr_fields_list_facet_map_callback',
      'index_type' => 'boolean',
      'facets' => TRUE,
      'facet missing allowed' => TRUE,
    ),
    'taxonomy_term_reference' => array(
      'map callback' => 'facetapi_map_taxonomy_terms',
      'hierarchy callback' => 'facetapi_get_taxonomy_hierarchy',
      'indexing_callback' => 'apachesolr_term_reference_indexing_callback',
      'index_type' => 'integer',
      'facet_block_callback' => 'apachesolr_search_taxonomy_facet_block',
      'facets' => TRUE,
    ),
  );

  return $mappings;
}

/**
 * Implements hook_apachesolr_field_mappings() on behalf of CCK.
 * @see http://drupal.org/node/1059372
 */
function content_apachesolr_field_mappings() {
  $mappings = array(
    'node_reference' => array(
      'display_callback' => 'apachesolr_cck_nodereference_field_callback',
      'indexing_callback' => 'apachesolr_cck_nodereference_indexing_callback',
      'index_type' => 'integer',
    ),
    'user_reference' => array(
      'display_callback' => 'apachesolr_cck_userreference_field_callback',
      'indexing_callback' => 'apachesolr_cck_userreference_indexing_callback',
      'index_type' => 'integer',
    ),
  );

  return $mappings;
}

/**
 * Returns a list of blocks. Used by hook_block
 */
function apachesolr_mlt_list_blocks() {
  $blocks = variable_get('apachesolr_mlt_blocks', array());
  foreach ($blocks as $delta => $settings) {
    $blocks[$delta] += array('info' => t('Apache Solr recommendations: !name', array('!name' => $settings['name'])) , 'cache' => DRUPAL_CACHE_PER_PAGE);
  }
  return $blocks;
}

function apachesolr_mlt_load_block($delta) {
  $blocks = variable_get('apachesolr_mlt_blocks', array());
  return isset($blocks[$delta]) ? $blocks[$delta] : FALSE;
}

function theme_apachesolr_mlt_recommendation_block($vars) {
  $docs = $vars['docs'];
  $links = array();
  foreach ($docs as $result) {
    // Suitable for single-site mode. Label is already safe.
    $links[] = l($result->label, $result->path, array('html' => TRUE));
  }
  return theme('item_list', array('items' => $links));
}

/**
 * A replacement for l()
 *  - doesn't add the 'active' class
 *  - retains all $_GET parameters that ApacheSolr may not be aware of
 *  - if set, $options['query'] MUST be an array
 *
 * @see http://api.drupal.org/api/function/l/6 for parameters and options.
 *
 * @return
 *   an HTML string containing a link to the given path.
 */
function apachesolr_l($text, $path, $options = array()) {
  // Merge in defaults.
  $options += array(
    'attributes' => array(),
    'html' => FALSE,
    'query' => array(),
  );

  // Don't need this, and just to be safe.
  unset($options['attributes']['title']);

  // Retain GET parameters that Apache Solr knows nothing about.
  $get = array_diff_key($_GET, array('q' => 1, 'page' => 1, 'solrsort' => 1), $options['query']);
  $options['query'] += $get;

  return '<a href="' . check_url(url($path, $options)) . '"' . drupal_attributes($options['attributes']) . '>' . ($options['html'] ? $text : check_plain(html_entity_decode($text))) . '</a>';
}

function theme_apachesolr_sort_link($vars) {
  $icon = '';
  if ($vars['direction']) {
    $icon = ' ' . theme('tablesort_indicator', array('style' => $vars['direction']));
  }
  if ($vars['active']) {
    if (isset($vars['options']['attributes']['class'])) {
      $vars['options']['attributes']['class'] .= ' active';
    }
    else {
      $vars['options']['attributes']['class'] = 'active';
    }
  }
  return $icon . apachesolr_l($vars['text'], $vars['path'], $vars['options']);
}

function theme_apachesolr_sort_list($vars) {
  // theme('item_list') expects a numerically indexed array.
  $vars['items'] = array_values($vars['items']);
  return theme('item_list', array('items' => $vars['items']));
}

/**
 * Themes the title for settings pages.
 */
function theme_apachesolr_settings_title($vars) {
  $output = '';

  // Gets environment information, builds header with nested link to the environment's
  // edit page. Skips building title if environment info could not be retrieved.
  if ($environment = apachesolr_environment_load($vars['env_id'])) {
    $url = url(
      'admin/config/search/apachesolr-env/' . $vars['env_id'],
      array('query' => array('destination' => $_GET['q']))
    );

    $output .= '<h3>';
    $output .= t(
      'Settings for: <a href="@url">@environment</a>',
      array('@url' => $url, '@environment' => $environment['name'])
    );
    $output .= "</h3>\n";
  }

  return $output;
}

/**
 * The interface for all 'query' objects.
 */
interface DrupalSolrQueryInterface {
  /**
   * Returns all filters matching $name, if set; otherwise, returns all filters.
   *
   * @param string $name
   *   The facet field name to match. If NULL, all filters will be returned.
   *
   * @return array
   *   All matching filters.
   */
  function getFilters($name = NULL);

  /**
   * Tests whether a filter is already present in the query.
   *
   * @param string $name
   *   The facet field name to check.
   * @param string $value
   *   The facet value to check.
   * @param boolean $exclude
   *   Optional, defaults to FALSE, must match the filter.
   *
   * @return boolean
   *   TRUE or FALSE.
   */
  function hasFilter($name, $value, $exclude = FALSE);

  /**
   * Adds a filter to the query.
   *
   * @param string $name
   *   The facet field name.
   * @param string $value
   *   The facet field value.
   * @param boolean $exclude
   *   Set to TRUE to filter out documents matching $value.
   * @param string $local
   *   Solr LocalParams.
   *
   * @return DrupalSolrQueryInterface
   *   The called object.
   */
  function addFilter($name, $value, $exclude = FALSE, $local = '');

  /**
   * Removes a filter from the query.
   *
   * @param string $name
   *   The name of the facet field to remove.
   * @param string $value
   *   The value of the facet field to remove. If NULL, all filters matching
   *   $name are removed.
   * @param boolean $exclude
   *   If $value is not NULL, only filters matching both $value and $exclude are
   *   removed. Ignored if $value is NULL.
   *
   * @return DrupalSolrQueryInterface
   *   The called object.
   */
  function removeFilter($name, $value = NULL, $exclude = FALSE);

  /**
   * Returns all subqueries to the query.
   *
   * @return array
   *   All subqueries to the query.
   */
  function getFilterSubQueries();

  /**
   * Adds a subquery to the query.
   *
   * @param SolrFilterSubQuery $query
   *   The query to add to the orginal query - may have keywords or filters.
   * @param string $fq_operator
   *   The operator to use within the filter part of the subquery
   * @param string $q_operator
   *   The operator to use in joining the subquery to the main keywords. Note:
   *   this is unlikely to work with the Dismax handler when the main query is
   *   only keywords.
   *
   * @return DrupalSolrQueryInterface
   *   The called object.
   */
  function addFilterSubQuery(SolrFilterSubQuery $query);

  /**
   * Removes a specific subquery.
   *
   * @param DrupalSolrQueryInterface $query
   *   The query to remove.
   *
   * @return DrupalSolrQueryInterface
   *   The called object.
   */
  function removeFilterSubQuery(SolrFilterSubQuery $query);

  /**
   * Removes all subqueries.
   *
   * @return DrupalSolrQueryInterface
   *   The called object.
   */
  function removeFilterSubQueries();

  /**
   * Transforms a single filter in a form suitable for use in a Solr query.
   *
   * @param array $filter
   *   A filter as an array with the keys '#name', for the facet field name,
   *   '#value', for the facet field value, '#local', for Solr LocalParams, and
       '#exclude' set to TRUE if it is an exclusion filter.
   *
   * @return string
   *   A Solr fq parameter value.
   */
  function makeFilterQuery(array $filter);

  /**
   * Gets the value of a parameter.
   *
   * @param string $name
   *   The parameter name.
   *
   * @return
   *   The value of the parameter.
   */
  function getParam($name);

  /**
   * Gets all parameters in normalized form.
   *
   * @return array
   *   All parameters as key-value pairs.
   */
  function getParams();

  /**
   * Gets parameters in a form suitable for use in a Solr query.
   *
   * @return array
   *   All parameters as key-value pairs, where values have been transformed
   *   into Solr parameter values.
   */
  function getSolrParams();

  /**
   * Adds a param to be sent when running the Solr search.
   *
   * If the param is single-valued, this will replace rather than add the value.
   *
   * @param string $name
   *   A Solr param name, e.g. 'q' or 'fl'.
   * @param $value
   *   A Solr param value: an array of values, or a string for a single value.
   *
   * @return DrupalSolrQueryInterface
   *   The called object.
   */
  function addParam($name, $value);

  /**
   * Adds multiple params to be sent when running the Solr search.
   *
   * If the param is single-valued, this will replace rather than add the value.
   *
   * @param $params
   *   An array where the keys are param names, and the values may be strings or
   *   arrays of strings.
   *
   * @return DrupalSolrQueryInterface
   *   The called object.
   */
  function addParams(array $params);

  /**
   * Removes all values for one Solr param.
   *
   * @param string $name
   *   A Solr param name, e.g. 'q' or 'fl'.
   *
   * @return DrupalSolrQueryInterface
   *   The called object.
   */
  function removeParam($name);

  /**
   * Replaces a param to be sent when running the Solr search.
   *
   * Basically a shortcut for removeParam() plus addParam().
   *
   * @param string $name
   *   A Solr param name, e.g. 'q' or 'fl'.
   * @param $value
   *   A Solr param value: an array of values, or a string for a single value.
   *
   * @return DrupalSolrQueryInterface
   *   The called object.
   */
  function replaceParam($name, $value);

  /**
   * Handles aliases for field to make nicer URLs.
   *
   * @param $field_map
   *   An array keyed with aliases with the real Solr index field name as value.
   *
   * @return DrupalSolrQueryInterface
   *   The called object.
   */
  function addFieldAliases($field_map);

  function getFieldAliases();

  function clearFieldAliases();

  function getAvailableSorts();

  /**
   * Adds an available sort.
   *
   * @param string $name
   *  The name of the field in the Solr index to sort on.
   * @param array $sort
   *  An array with the keys 'title', for the human name of the sort, and
   *  'default', for the default sort direction ('asc' or 'desc').
   *
   * @return DrupalSolrQueryInterface
   *   The called object.
   */
  function setAvailableSort($name, $sort);

  /**
   * Removes an available sort.
   *
   * @param string $name
   *  The name of the field in the Solr index to sort on.
   *
   * @return DrupalSolrQueryInterface
   *   The called object.
   */
  function removeAvailableSort($name);

  /**
   * Gets the current sort.
   *
   * @return array
   *   The current sort as an array with the keys '#name', for the name of
   *   the field, and '#direction', for the sort direction ('asc' or 'desc').
   */
  function getSolrsort();

  /**
   * Sets the sort.
   *
   * @param string $field
   *  The name of the field in the Solr index to sort on.
   * @param string $direction
   *  'asc' or 'desc'
   *
   * @return DrupalSolrQueryInterface
   *   The called object.
   */
  function setSolrsort($name, $direction);

  /**
   * Returns an array representing the URL query string for the current sort.
   *
   * @return array
   *   The URL query string for the current sort.
   */
  function getSolrsortUrlQuery();

  /**
   * Returns the search path (including the search keywords).
   *
   * @param string $new_keywords
   *   Optional. When set, this string overrides the query's current keywords.
   *
   * @return string
   *   The search path.
   */
  function getPath($new_keywords = NULL);

  /**
   * Sends the search request to Solr, unless $query->abort_search is TRUE.
   *
   * @param string $keys
   *   The search keys.
   *
   * @return
   *   A stdClass response object.
   */
  function search($keys = NULL);

  /**
   * Calls a method, without arguments, on the Solr object with which the query
   * object was initialized.
   *
   * @param string $method
   *   The method to call on the Solr object.
   *
   * @return
   *   Any method return.
   */
  function solr($method);
}
